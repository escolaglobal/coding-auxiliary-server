<html><head>
    <title>Express</title>
  <style type="text/css"></style></head>
  <body>
Yo, uploading yo' shizzle now.
</body>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>
var blocks = [
   {
      "functionality":"Blockly.Python['colour_blend'] = function(block) {\n  // Blend two colours together.\n  var functionName = Blockly.Python.provideFunction_(\n      'colour_blend',\n      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +\n          '(colour1, colour2, ratio):',\n       '  r1, r2 = int(colour1[1:3], 16), int(colour2[1:3], 16)',\n       '  g1, g2 = int(colour1[3:5], 16), int(colour2[3:5], 16)',\n       '  b1, b2 = int(colour1[5:7], 16), int(colour2[5:7], 16)',\n       '  ratio = min(1, max(0, ratio))',\n       '  r = round(r1 * (1 - ratio) + r2 * ratio)',\n       '  g = round(g1 * (1 - ratio) + g2 * ratio)',\n       '  b = round(b1 * (1 - ratio) + b2 * ratio)',\n       '  return \\'#%02x%02x%02x\\' % (r, g, b)']);\n  var colour1 = Blockly.Python.valueToCode(block, 'COLOUR1',\n      Blockly.Python.ORDER_NONE) || '\\'#000000\\'';\n  var colour2 = Blockly.Python.valueToCode(block, 'COLOUR2',\n      Blockly.Python.ORDER_NONE) || '\\'#000000\\'';\n  var ratio = Blockly.Python.valueToCode(block, 'RATIO',\n      Blockly.Python.ORDER_NONE) || 0;\n  var code = functionName + '(' + colour1 + ', ' + colour2 + ', ' + ratio + ')';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n};",
      "name":"colour_blend",
      "structure":"Blockly.Blocks['colour_blend'] = {\n  /**\n   * Block for blending two colours together.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.COLOUR_BLEND_HELPURL);\n    this.setColour(20);\n    this.appendValueInput('COLOUR1')\n        .setCheck('Colour')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_BLEND_TITLE)\n        .appendField(Blockly.Msg.COLOUR_BLEND_COLOUR1);\n    this.appendValueInput('COLOUR2')\n        .setCheck('Colour')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_BLEND_COLOUR2);\n    this.appendValueInput('RATIO')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_BLEND_RATIO);\n    this.setOutput(true, 'Colour');\n    this.setTooltip(Blockly.Msg.COLOUR_BLEND_TOOLTIP);\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['colour_picker'] = function(block) {\n  // Colour picker.\n  var code = '\\'' + block.getFieldValue('COLOUR') + '\\'';\n  return [code, Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"colour_picker",
      "structure":"Blockly.Blocks['colour_picker'] = {\n  /**\n   * Block for colour picker.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.COLOUR_PICKER_HELPURL);\n    this.setColour(20);\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldColour('#ff0000'), 'COLOUR');\n    this.setOutput(true, 'Colour');\n    this.setTooltip(Blockly.Msg.COLOUR_PICKER_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['colour_random'] = function(block) {\n  // Generate a random colour.\n  Blockly.Python.definitions_['import_random'] = 'import random';\n  var code = '\\'#%06x\\' % random.randint(0, 2**24 - 1)';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"colour_random",
      "structure":"Blockly.Blocks['colour_random'] = {\n  /**\n   * Block for random colour.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.COLOUR_RANDOM_HELPURL);\n    this.setColour(20);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.COLOUR_RANDOM_TITLE);\n    this.setOutput(true, 'Colour');\n    this.setTooltip(Blockly.Msg.COLOUR_RANDOM_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['colour_rgb'] = function(block) {\n  // Compose a colour from RGB components expressed as percentages.\n  var functionName = Blockly.Python.provideFunction_(\n      'colour_rgb',\n      [ 'def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(r, g, b):',\n        '  r = round(min(100, max(0, r)) * 2.55)',\n        '  g = round(min(100, max(0, g)) * 2.55)',\n        '  b = round(min(100, max(0, b)) * 2.55)',\n        '  return \\'#%02x%02x%02x\\' % (r, g, b)']);\n  var r = Blockly.Python.valueToCode(block, 'RED',\n                                     Blockly.Python.ORDER_NONE) || 0;\n  var g = Blockly.Python.valueToCode(block, 'GREEN',\n                                     Blockly.Python.ORDER_NONE) || 0;\n  var b = Blockly.Python.valueToCode(block, 'BLUE',\n                                     Blockly.Python.ORDER_NONE) || 0;\n  var code = functionName + '(' + r + ', ' + g + ', ' + b + ')';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"colour_rgb",
      "structure":"Blockly.Blocks['colour_rgb'] = {\n  /**\n   * Block for composing a colour from RGB components.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.COLOUR_RGB_HELPURL);\n    this.setColour(20);\n    this.appendValueInput('RED')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_TITLE)\n        .appendField(Blockly.Msg.COLOUR_RGB_RED);\n    this.appendValueInput('GREEN')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_GREEN);\n    this.appendValueInput('BLUE')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_BLUE);\n    this.setOutput(true, 'Colour');\n    this.setTooltip(Blockly.Msg.COLOUR_RGB_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['controls_flow_statements'] = function(block) {\n  // Flow statements: continue, break.\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return 'break\\n';\n    case 'CONTINUE':\n      return 'continue\\n';\n  }\n  throw 'Unknown flow statement.';\n\n};",
      "name":"controls_flow_statements",
      "structure":"Blockly.Blocks['controls_flow_statements'] = {\n  /**\n   * Block for flow statements: continue, break.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK, 'BREAK'],\n         [Blockly.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE, 'CONTINUE']];\n    this.setHelpUrl(Blockly.Msg.CONTROLS_FLOW_STATEMENTS_HELPURL);\n    this.setColour(120);\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'FLOW');\n    this.setPreviousStatement(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var op = thisBlock.getFieldValue('FLOW');\n      var TOOLTIPS = {\n        'BREAK': Blockly.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,\n        'CONTINUE': Blockly.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE\n      };\n      return TOOLTIPS[op];\n    });\n  },\n  /**\n   * Called whenever anything on the workspace changes.\n   * Add warning if this flow block is not nested inside a loop.\n   * @this Blockly.Block\n   */\n  onchange: function() {\n    if (!this.workspace) {\n      // Block has been deleted.\n      return;\n    }\n    var legal = false;\n    // Is the block nested in a control statement?\n    var block = this;\n    do {\n      if (block.type == 'controls_repeat' ||\n          block.type == 'controls_repeat_ext' ||\n          block.type == 'controls_forEach' ||\n          block.type == 'controls_for' ||\n          block.type == 'controls_whileUntil') {\n        legal = true;\n        break;\n      }\n      block = block.getSurroundParent();\n    } while (block);\n    if (legal) {\n      this.setWarningText(null);\n    } else {\n      this.setWarningText(Blockly.Msg.CONTROLS_FLOW_STATEMENTS_WARNING);\n    }\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['controls_for'] = function(block) {\n  // For loop.\n  var variable0 = Blockly.Python.variableDB_.getName(\n      block.getFieldValue('VAR'), Blockly.Variables.NAME_TYPE);\n  var argument0 = Blockly.Python.valueToCode(block, 'FROM',\n      Blockly.Python.ORDER_NONE) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'TO',\n      Blockly.Python.ORDER_NONE) || '0';\n  var increment = Blockly.Python.valueToCode(block, 'BY',\n      Blockly.Python.ORDER_NONE) || '1';\n  var branch = Blockly.Python.statementToCode(block, 'DO');\n  branch = Blockly.Python.addLoopTrap(branch, block.id) ||\n      Blockly.Python.PASS;\n\n  var code = '';\n  var range;\n\n  // Helper functions.\n  var defineUpRange = function() {\n    return Blockly.Python.provideFunction_(\n        'upRange',\n        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +\n            '(start, stop, step):',\n         '  while start <= stop:',\n         '    yield start',\n         '    start += abs(step)']);\n  };\n  var defineDownRange = function() {\n    return Blockly.Python.provideFunction_(\n        'downRange',\n        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +\n            '(start, stop, step):',\n         '  while start >= stop:',\n         '    yield start',\n         '    start -= abs(step)']);\n  };\n  // Arguments are legal Python code (numbers or strings returned by scrub()).\n  var generateUpDownRange = function(start, end, inc) {\n    return '(' + start + ' <= ' + end + ') and ' +\n        defineUpRange() + '(' + start + ', ' + end + ', ' + inc + ') or ' +\n        defineDownRange() + '(' + start + ', ' + end + ', ' + inc + ')';\n  };\n\n  if (Blockly.isNumber(argument0) && Blockly.isNumber(argument1) &&\n      Blockly.isNumber(increment)) {\n    // All parameters are simple numbers.\n    argument0 = parseFloat(argument0);\n    argument1 = parseFloat(argument1);\n    increment = Math.abs(parseFloat(increment));\n    if (argument0 % 1 === 0 && argument1 % 1 === 0 && increment % 1 === 0) {\n      // All parameters are integers.\n      if (argument0 <= argument1) {\n        // Count up.\n        argument1++;\n        if (argument0 == 0 && increment == 1) {\n          // If starting index is 0, omit it.\n          range = argument1;\n        } else {\n          range = argument0 + ', ' + argument1;\n        }\n        // If increment isn't 1, it must be explicit.\n        if (increment != 1) {\n          range += ', ' + increment;\n        }\n      } else {\n        // Count down.\n        argument1--;\n        range = argument0 + ', ' + argument1 + ', -' + increment;\n      }\n      range = 'range(' + range + ')';\n    } else {\n      // At least one of the parameters is not an integer.\n      if (argument0 < argument1) {\n        range = defineUpRange();\n      } else {\n        range = defineDownRange();\n      }\n      range += '(' + argument0 + ', ' + argument1 + ', ' + increment + ')';\n    }\n  } else {\n    // Cache non-trivial values to variables to prevent repeated look-ups.\n    var scrub = function(arg, suffix) {\n      if (Blockly.isNumber(arg)) {\n        // Simple number.\n        arg = parseFloat(arg);\n      } else if (arg.match(/^\\w+$/)) {\n        // Variable.\n        arg = 'float(' + arg + ')';\n      } else {\n        // It's complicated.\n        var varName = Blockly.Python.variableDB_.getDistinctName(\n            variable0 + suffix, Blockly.Variables.NAME_TYPE);\n        code += varName + ' = float(' + arg + ')\\n';\n        arg = varName;\n      }\n      return arg;\n    };\n    var startVar = scrub(argument0, '_start');\n    var endVar = scrub(argument1, '_end');\n    var incVar = scrub(increment, '_inc');\n\n    if (typeof startVar == 'number' && typeof endVar == 'number') {\n      if (startVar < endVar) {\n        range = defineUpRange(startVar, endVar, increment);\n      } else {\n        range = defineDownRange(startVar, endVar, increment);\n      }\n    } else {\n      // We cannot determine direction statically.\n      range = generateUpDownRange(startVar, endVar, increment);\n    }\n  }\n  code += 'for ' + variable0 + ' in ' + range + ':\\n' + branch;\n  return code;\n};",
      "name":"controls_for",
      "structure":"Blockly.Blocks['controls_for'] = {\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.CONTROLS_FOR_HELPURL);\n    this.setColour(120);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.CONTROLS_FOR_INPUT_WITH)\n        .appendField(new Blockly.FieldVariable(null), 'VAR');\n    this.interpolateMsg(\"de %1 atÃ© %2 em saltos de %3\",\n                        ['FROM', 'Number', Blockly.ALIGN_RIGHT],\n                        ['TO', 'Number', Blockly.ALIGN_RIGHT],\n                        ['BY', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.appendStatementInput('DO')\n        .appendField(Blockly.Msg.CONTROLS_FOR_INPUT_DO);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setInputsInline(true);\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return Blockly.Msg.CONTROLS_FOR_TOOLTIP.replace('%1',\n          thisBlock.getFieldValue('VAR'));\n    });\n  },\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  },\n  customContextMenu: function(options) {\n    if (!this.isCollapsed()) {\n      var option = {enabled: true};\n      var name = this.getFieldValue('VAR');\n      option.text = Blockly.Msg.VARIABLES_SET_CREATE_GET.replace('%1', name);\n      var xmlField = goog.dom.createDom('field', null, name);\n      xmlField.setAttribute('name', 'VAR');\n      var xmlBlock = goog.dom.createDom('block', null, xmlField);\n      xmlBlock.setAttribute('type', 'variables_get');\n      option.callback = Blockly.ContextMenu.callbackFactory(this, xmlBlock);\n      options.push(option);\n    }\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['controls_forEach'] = function(block) {\n  // For each loop.\n  var variable0 = Blockly.Python.variableDB_.getName(\n      block.getFieldValue('VAR'), Blockly.Variables.NAME_TYPE);\n  var argument0 = Blockly.Python.valueToCode(block, 'LIST',\n      Blockly.Python.ORDER_RELATIONAL) || '[]';\n  var branch = Blockly.Python.statementToCode(block, 'DO');\n  branch = Blockly.Python.addLoopTrap(branch, block.id) ||\n      Blockly.Python.PASS;\n  var code = 'for ' + variable0 + ' in ' + argument0 + ':\\n' + branch;\n  return code;\n\n\n};",
      "name":"controls_forEach",
      "structure":"Blockly.Blocks['controls_forEach'] = {\n  /**\n   * Block for 'for each' loop.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.CONTROLS_FOREACH_HELPURL);\n    this.setColour(120);\n    this.appendValueInput('LIST')\n        .setCheck('Array')\n        .appendField(Blockly.Msg.CONTROLS_FOREACH_INPUT_ITEM)\n        .appendField(new Blockly.FieldVariable(null), 'VAR')\n        .appendField(Blockly.Msg.CONTROLS_FOREACH_INPUT_INLIST);\n    if (Blockly.Msg.CONTROLS_FOREACH_INPUT_INLIST_TAIL) {\n      this.appendDummyInput()\n          .appendField(Blockly.Msg.CONTROLS_FOREACH_INPUT_INLIST_TAIL);\n      this.setInputsInline(true);\n    }\n    this.appendStatementInput('DO')\n        .appendField(Blockly.Msg.CONTROLS_FOREACH_INPUT_DO);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return Blockly.Msg.CONTROLS_FOREACH_TOOLTIP.replace('%1',\n          thisBlock.getFieldValue('VAR'));\n    });\n  },\n  /**\n   * Return all variables referenced by this block.\n   * @return   List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  },\n  customContextMenu: Blockly.Blocks['controls_for'].customContextMenu};"
   },
   {
      "functionality":"Blockly.Python['controls_if'] = function(block) {\n  // If/elseif/else condition.\n  var n = 0;\n  var argument = Blockly.Python.valueToCode(block, 'IF' + n,\n      Blockly.Python.ORDER_NONE) || 'False';\n  var branch = Blockly.Python.statementToCode(block, 'DO' + n) ||\n      Blockly.Python.PASS;\n  var code = 'if ' + argument + ':\\n' + branch;\n  for (n = 1; n <= block.elseifCount_; n++) {\n    argument = Blockly.Python.valueToCode(block, 'IF' + n,\n        Blockly.Python.ORDER_NONE) || 'False';\n    branch = Blockly.Python.statementToCode(block, 'DO' + n) ||\n        Blockly.Python.PASS;\n    code += 'elif ' + argument + ':\\n' + branch;\n  }\n  if (block.elseCount_) {\n    branch = Blockly.Python.statementToCode(block, 'ELSE') ||\n        Blockly.Python.PASS;\n    code += 'else:\\n' + branch;\n  }\n  return code;\n\n\n};",
      "name":"controls_if",
      "structure":"Blockly.Blocks['controls_if'] = {\n  /**\n   * Block for if/elseif/else condition.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.CONTROLS_IF_HELPURL);\n    this.setColour(210);\n    this.appendValueInput('IF0')\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);\n    this.appendStatementInput('DO0')\n        .appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setMutator(new Blockly.Mutator(['controls_if_elseif',\n                                         'controls_if_else']));\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      if (!thisBlock.elseifCount_ && !thisBlock.elseCount_) {\n        return Blockly.Msg.CONTROLS_IF_TOOLTIP_1;\n      } else if (!thisBlock.elseifCount_ && thisBlock.elseCount_) {\n        return Blockly.Msg.CONTROLS_IF_TOOLTIP_2;\n      } else if (thisBlock.elseifCount_ && !thisBlock.elseCount_) {\n        return Blockly.Msg.CONTROLS_IF_TOOLTIP_3;\n      } else if (thisBlock.elseifCount_ && thisBlock.elseCount_) {\n        return Blockly.Msg.CONTROLS_IF_TOOLTIP_4;\n      }\n      return '';\n    });\n    this.elseifCount_ = 0;\n    this.elseCount_ = 0;\n  },\n  /**\n   * Create XML to represent the number of else-if and else inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    if (!this.elseifCount_ && !this.elseCount_) {\n      return null;\n    }\n    var container = document.createElement('mutation');\n    if (this.elseifCount_) {\n      container.setAttribute('elseif', this.elseifCount_);\n    }\n    if (this.elseCount_) {\n      container.setAttribute('else', 1);\n    }\n    return container;\n  },\n  /**\n   * Parse XML to restore the else-if and else inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    this.elseifCount_ = parseInt(xmlElement.getAttribute('elseif'), 10);\n    this.elseCount_ = parseInt(xmlElement.getAttribute('else'), 10);\n    for (var i = 1; i <= this.elseifCount_; i++) {\n      this.appendValueInput('IF' + i)\n          .setCheck('Boolean')\n          .appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSEIF);\n      this.appendStatementInput('DO' + i)\n          .appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);\n    }\n    if (this.elseCount_) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSE);\n    }\n  },\n  /**\n   * Populate the mutator's dialog with this block's components.\n   * @param {!Blockly.Workspace} workspace Mutator's workspace.\n   * @return {!Blockly.Block} Root block in mutator.\n   * @this Blockly.Block\n   */\n  decompose: function(workspace) {\n    var containerBlock = Blockly.Block.obtain(workspace, 'controls_if_if');\n    containerBlock.initSvg();\n    var connection = containerBlock.getInput('STACK').connection;\n    for (var i = 1; i <= this.elseifCount_; i++) {\n      var elseifBlock = Blockly.Block.obtain(workspace, 'controls_if_elseif');\n      elseifBlock.initSvg();\n      connection.connect(elseifBlock.previousConnection);\n      connection = elseifBlock.nextConnection;\n    }\n    if (this.elseCount_) {\n      var elseBlock = Blockly.Block.obtain(workspace, 'controls_if_else');\n      elseBlock.initSvg();\n      connection.connect(elseBlock.previousConnection);\n    }\n    return containerBlock;\n  },\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  compose: function(containerBlock) {\n    // Disconnect the else input blocks and remove the inputs.\n    if (this.elseCount_) {\n      this.removeInput('ELSE');\n    }\n    this.elseCount_ = 0;\n    // Disconnect all the elseif input blocks and remove the inputs.\n    for (var i = this.elseifCount_; i > 0; i--) {\n      this.removeInput('IF' + i);\n      this.removeInput('DO' + i);\n    }\n    this.elseifCount_ = 0;\n    // Rebuild the block's optional inputs.\n    var clauseBlock = containerBlock.getInputTargetBlock('STACK');\n    while (clauseBlock) {\n      switch (clauseBlock.type) {\n        case 'controls_if_elseif':\n          this.elseifCount_++;\n          var ifInput = this.appendValueInput('IF' + this.elseifCount_)\n              .setCheck('Boolean')\n              .appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSEIF);\n          var doInput = this.appendStatementInput('DO' + this.elseifCount_);\n          doInput.appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);\n          // Reconnect any child blocks.\n          if (clauseBlock.valueConnection_) {\n            ifInput.connection.connect(clauseBlock.valueConnection_);\n          }\n          if (clauseBlock.statementConnection_) {\n            doInput.connection.connect(clauseBlock.statementConnection_);\n          }\n          break;\n        case 'controls_if_else':\n          this.elseCount_++;\n          var elseInput = this.appendStatementInput('ELSE');\n          elseInput.appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSE);\n          // Reconnect any child blocks.\n          if (clauseBlock.statementConnection_) {\n            elseInput.connection.connect(clauseBlock.statementConnection_);\n          }\n          break;\n        default:\n          throw 'Unknown block type.';\n      }\n      clauseBlock = clauseBlock.nextConnection &&\n          clauseBlock.nextConnection.targetBlock();\n    }\n  },\n  /**\n   * Store pointers to any connected child blocks.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  saveConnections: function(containerBlock) {\n    var clauseBlock = containerBlock.getInputTargetBlock('STACK');\n    var i = 1;\n    while (clauseBlock) {\n      switch (clauseBlock.type) {\n        case 'controls_if_elseif':\n          var inputIf = this.getInput('IF' + i);\n          var inputDo = this.getInput('DO' + i);\n          clauseBlock.valueConnection_ =\n              inputIf && inputIf.connection.targetConnection;\n          clauseBlock.statementConnection_ =\n              inputDo && inputDo.connection.targetConnection;\n          i++;\n          break;\n        case 'controls_if_else':\n          var inputDo = this.getInput('ELSE');\n          clauseBlock.statementConnection_ =\n              inputDo && inputDo.connection.targetConnection;\n          break;\n        default:\n          throw 'Unknown block type.';\n      }\n      clauseBlock = clauseBlock.nextConnection &&\n          clauseBlock.nextConnection.targetBlock();\n    }\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"controls_if_else",
      "structure":"Blockly.Blocks['controls_if_else'] = {\n  /**\n   * Mutator block for else condition.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(210);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.CONTROLS_IF_ELSE_TITLE_ELSE);\n    this.setPreviousStatement(true);\n    this.setTooltip(Blockly.Msg.CONTROLS_IF_ELSE_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"controls_if_elseif",
      "structure":"Blockly.Blocks['controls_if_elseif'] = {\n  /**\n   * Mutator bolck for else-if condition.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(210);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.CONTROLS_IF_ELSEIF_TITLE_ELSEIF);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.CONTROLS_IF_ELSEIF_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"controls_if_if",
      "structure":"Blockly.Blocks['controls_if_if'] = {\n  /**\n   * Mutator block for if container.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(210);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.CONTROLS_IF_IF_TITLE_IF);\n    this.appendStatementInput('STACK');\n    this.setTooltip(Blockly.Msg.CONTROLS_IF_IF_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['controls_repeat'] = function(block) {\n  // Repeat n times (internal number).\n  var repeats = parseInt(block.getFieldValue('TIMES'), 10);\n  var branch = Blockly.Python.statementToCode(block, 'DO');\n  branch = Blockly.Python.addLoopTrap(branch, block.id) ||\n      Blockly.Python.PASS;\n  var loopVar = Blockly.Python.variableDB_.getDistinctName(\n      'count', Blockly.Variables.NAME_TYPE);\n  var code = 'for ' + loopVar + ' in range(' + repeats + '):\\n' + branch;\n  return code;\n\n\n};",
      "name":"controls_repeat",
      "structure":"Blockly.Blocks['controls_repeat'] = {\n  /**\n   * Block for repeat n times (internal number).\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.CONTROLS_REPEAT_HELPURL);\n    this.setColour(120);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT)\n        .appendField(new Blockly.FieldTextInput('10',\n            Blockly.FieldTextInput.nonnegativeIntegerValidator), 'TIMES')\n        .appendField(Blockly.Msg.CONTROLS_REPEAT_TITLE_TIMES);\n    this.appendStatementInput('DO')\n        .appendField(Blockly.Msg.CONTROLS_REPEAT_INPUT_DO);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.CONTROLS_REPEAT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['controls_repeat_ext'] = function(block) {\n  // Repeat n times (external number).\n  var repeats = Blockly.Python.valueToCode(block, 'TIMES',\n      Blockly.Python.ORDER_NONE) || '0';\n  if (Blockly.isNumber(repeats)) {\n    repeats = parseInt(repeats, 10);\n  } else {\n    repeats = 'int(' + repeats + ')';\n  }\n  var branch = Blockly.Python.statementToCode(block, 'DO');\n  branch = Blockly.Python.addLoopTrap(branch, block.id) ||\n      Blockly.Python.PASS;\n  var loopVar = Blockly.Python.variableDB_.getDistinctName(\n      'count', Blockly.Variables.NAME_TYPE);\n  var code = 'for ' + loopVar + ' in range(' + repeats + '):\\n' + branch;\n  return code;\n\n\n};",
      "name":"controls_repeat_ext",
      "structure":"Blockly.Blocks['controls_repeat_ext'] = {\n  /**\n   * Block for repeat n times (external number).\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.CONTROLS_REPEAT_HELPURL);\n    this.setColour(120);\n    this.interpolateMsg(Blockly.Msg.CONTROLS_REPEAT_TITLE,\n                        ['TIMES', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.appendStatementInput('DO')\n        .appendField(Blockly.Msg.CONTROLS_REPEAT_INPUT_DO);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.CONTROLS_REPEAT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['controls_whileUntil'] = function(block) {\n  // Do while/until loop.\n  var until = block.getFieldValue('MODE') == 'UNTIL';\n  var argument0 = Blockly.Python.valueToCode(block, 'BOOL',\n      until ? Blockly.Python.ORDER_LOGICAL_NOT :\n      Blockly.Python.ORDER_NONE) || 'False';\n  var branch = Blockly.Python.statementToCode(block, 'DO');\n  branch = Blockly.Python.addLoopTrap(branch, block.id) ||\n      Blockly.Python.PASS;\n  if (until) {\n    argument0 = 'not ' + argument0;\n  }\n  return 'while ' + argument0 + ':\\n' + branch;\n\n\n};",
      "name":"controls_whileUntil",
      "structure":"Blockly.Blocks['controls_whileUntil'] = {\n  /**\n   * Block for 'do while/until' loop.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.CONTROLS_WHILEUNTIL_OPERATOR_WHILE, 'WHILE'],\n         [Blockly.Msg.CONTROLS_WHILEUNTIL_OPERATOR_UNTIL, 'UNTIL']];\n    this.setHelpUrl(Blockly.Msg.CONTROLS_WHILEUNTIL_HELPURL);\n    this.setColour(120);\n    this.appendValueInput('BOOL')\n        .setCheck('Boolean')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'MODE');\n    this.appendStatementInput('DO')\n        .appendField(Blockly.Msg.CONTROLS_WHILEUNTIL_INPUT_DO);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var op = thisBlock.getFieldValue('MODE');\n      var TOOLTIPS = {\n        'WHILE': Blockly.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_WHILE,\n        'UNTIL': Blockly.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL\n      };\n      return TOOLTIPS[op];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['lists_create_empty'] = function(block) {\n  // Create an empty list.\n  return ['[]', Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"lists_create_empty",
      "structure":"Blockly.Blocks['lists_create_empty'] = {\n  /**\n   * Block for creating an empty list.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LISTS_CREATE_EMPTY_HELPURL);\n    this.setColour(260);\n    this.setOutput(true, 'Array');\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.LISTS_CREATE_EMPTY_TITLE);\n    this.setTooltip(Blockly.Msg.LISTS_CREATE_EMPTY_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_create_with'] = function(block) {\n  // Create a list with any number of elements of any type.\n  var code = new Array(block.itemCount_);\n  for (var n = 0; n < block.itemCount_; n++) {\n    code[n] = Blockly.Python.valueToCode(block, 'ADD' + n,\n        Blockly.Python.ORDER_NONE) || 'None';\n  }\n  code = '[' + code.join(', ') + ']';\n  return [code, Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"lists_create_with",
      "structure":"Blockly.Blocks['lists_create_with'] = {\n  /**\n   * Block for creating a list with any number of elements of any type.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_HELPURL);\n    this.setColour(260);\n    this.itemCount_ = 3;\n    this.updateShape_();\n    this.setOutput(true, 'Array');\n    this.setMutator(new Blockly.Mutator(['lists_create_with_item']));\n    this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_TOOLTIP);\n  },\n  /**\n   * Create XML to represent list inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n  /**\n   * Parse XML to restore the list inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_();\n  },\n  /**\n   * Populate the mutator's dialog with this block's components.\n   * @param {!Blockly.Workspace} workspace Mutator's workspace.\n   * @return {!Blockly.Block} Root block in mutator.\n   * @this Blockly.Block\n   */\n  decompose: function(workspace) {\n    var containerBlock =\n        Blockly.Block.obtain(workspace, 'lists_create_with_container');\n    containerBlock.initSvg();\n    var connection = containerBlock.getInput('STACK').connection;\n    for (var i = 0; i < this.itemCount_; i++) {\n      var itemBlock = Blockly.Block.obtain(workspace, 'lists_create_with_item');\n      itemBlock.initSvg();\n      connection.connect(itemBlock.previousConnection);\n      connection = itemBlock.nextConnection;\n    }\n    return containerBlock;\n  },\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  compose: function(containerBlock) {\n    var itemBlock = containerBlock.getInputTargetBlock('STACK');\n    // Count number of inputs.\n    var connections = [];\n    var i = 0;\n    while (itemBlock) {\n      connections[i] = itemBlock.valueConnection_;\n      itemBlock = itemBlock.nextConnection &&\n          itemBlock.nextConnection.targetBlock();\n      i++;\n    }\n    this.itemCount_ = i;\n    this.updateShape_();\n    // Reconnect any child blocks.\n    for (var i = 0; i < this.itemCount_; i++) {\n      if (connections[i]) {\n        this.getInput('ADD' + i).connection.connect(connections[i]);\n      }\n    }\n  },\n  /**\n   * Store pointers to any connected child blocks.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  saveConnections: function(containerBlock) {\n    var itemBlock = containerBlock.getInputTargetBlock('STACK');\n    var i = 0;\n    while (itemBlock) {\n      var input = this.getInput('ADD' + i);\n      itemBlock.valueConnection_ = input && input.connection.targetConnection;\n      i++;\n      itemBlock = itemBlock.nextConnection &&\n          itemBlock.nextConnection.targetBlock();\n    }\n  },\n  /**\n   * Modify this block to have the correct number of inputs.\n   * @private\n   * @this Blockly.Block\n   */\n  updateShape_: function() {\n    // Delete everything.\n    if (this.getInput('EMPTY')) {\n      this.removeInput('EMPTY');\n    } else {\n      var i = 0;\n      while (this.getInput('ADD' + i)) {\n        this.removeInput('ADD' + i);\n        i++;\n      }\n    }\n    // Rebuild block.\n    if (this.itemCount_ == 0) {\n      this.appendDummyInput('EMPTY')\n          .appendField(Blockly.Msg.LISTS_CREATE_EMPTY_TITLE);\n    } else {\n      for (var i = 0; i < this.itemCount_; i++) {\n        var input = this.appendValueInput('ADD' + i);\n        if (i == 0) {\n          input.appendField(Blockly.Msg.LISTS_CREATE_WITH_INPUT_WITH);\n        }\n      }\n    }\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"lists_create_with_container",
      "structure":"Blockly.Blocks['lists_create_with_container'] = {\n  /**\n   * Mutator block for list container.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(260);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD);\n    this.appendStatementInput('STACK');\n    this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"lists_create_with_item",
      "structure":"Blockly.Blocks['lists_create_with_item'] = {\n  /**\n   * Mutator bolck for adding items.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(260);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TITLE);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_getIndex'] = function(block) {\n  // Get element at index.\n  // Note: Until January 2013 this block did not have MODE or WHERE inputs.\n  var mode = block.getFieldValue('MODE') || 'GET';\n  var where = block.getFieldValue('WHERE') || 'FROM_START';\n  var at = Blockly.Python.valueToCode(block, 'AT',\n      Blockly.Python.ORDER_UNARY_SIGN) || '1';\n  var list = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_MEMBER) || '[]';\n\n  if (where == 'FIRST') {\n    if (mode == 'GET') {\n      var code = list + '[0]';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    } else {\n      var code = list + '.pop(0)';\n      if (mode == 'GET_REMOVE') {\n        return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n      } else if (mode == 'REMOVE') {\n        return code + '\\n';\n      }\n    }\n  } else if (where == 'LAST') {\n    if (mode == 'GET') {\n      var code = list + '[-1]';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    } else {\n      var code = list + '.pop()';\n      if (mode == 'GET_REMOVE') {\n        return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n      } else if (mode == 'REMOVE') {\n        return code + '\\n';\n      }\n    }\n  } else if (where == 'FROM_START') {\n    // Blockly uses one-based indicies.\n    if (Blockly.isNumber(at)) {\n      // If the index is a naked number, decrement it right now.\n      at = parseInt(at, 10) - 1;\n    } else {\n      // If the index is dynamic, decrement it in code.\n      at = 'int(' + at + ' - 1)';\n    }\n    if (mode == 'GET') {\n      var code = list + '[' + at + ']';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    } else {\n      var code = list + '.pop(' + at + ')';\n      if (mode == 'GET_REMOVE') {\n        return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n      } else if (mode == 'REMOVE') {\n        return code + '\\n';\n      }\n    }\n  } else if (where == 'FROM_END') {\n    if (mode == 'GET') {\n      var code = list + '[-' + at + ']';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    } else {\n      var code = list + '.pop(-' + at + ')';\n      if (mode == 'GET_REMOVE') {\n        return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n      } else if (mode == 'REMOVE') {\n        return code + '\\n';\n      }\n    }\n  } else if (where == 'RANDOM') {\n    Blockly.Python.definitions_['import_random'] = 'import random';\n    if (mode == 'GET') {\n      code = 'random.choice(' + list + ')';\n      return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n    } else {\n      var functionName = Blockly.Python.provideFunction_(\n          'lists_remove_random_item',\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',\n           '  x = int(random.random() * len(myList))',\n           '  return myList.pop(x)']);\n      code = functionName + '(' + list + ')';\n      if (mode == 'GET_REMOVE') {\n        return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n      } else if (mode == 'REMOVE') {\n        return code + '\\n';\n      }\n    }\n  }\n  throw 'Unhandled combination (lists_getIndex).';\n\n\n};",
      "name":"lists_getIndex",
      "structure":"Blockly.Blocks['lists_getIndex'] = {\n  /**\n   * Block for getting element at index.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var MODE =\n        [[Blockly.Msg.LISTS_GET_INDEX_GET, 'GET'],\n         [Blockly.Msg.LISTS_GET_INDEX_GET_REMOVE, 'GET_REMOVE'],\n         [Blockly.Msg.LISTS_GET_INDEX_REMOVE, 'REMOVE']];\n    this.WHERE_OPTIONS =\n        [[Blockly.Msg.LISTS_GET_INDEX_FROM_START, 'FROM_START'],\n         [Blockly.Msg.LISTS_GET_INDEX_FROM_END, 'FROM_END'],\n         [Blockly.Msg.LISTS_GET_INDEX_FIRST, 'FIRST'],\n         [Blockly.Msg.LISTS_GET_INDEX_LAST, 'LAST'],\n         [Blockly.Msg.LISTS_GET_INDEX_RANDOM, 'RANDOM']];\n    this.setHelpUrl(Blockly.Msg.LISTS_GET_INDEX_HELPURL);\n    this.setColour(260);\n    var modeMenu = new Blockly.FieldDropdown(MODE, function(value) {\n      var isStatement = (value == 'REMOVE');\n      this.sourceBlock_.updateStatement_(isStatement);\n    });\n    this.appendValueInput('VALUE')\n        .setCheck('Array')\n        .appendField(Blockly.Msg.LISTS_GET_INDEX_INPUT_IN_LIST);\n    this.appendDummyInput()\n        .appendField(modeMenu, 'MODE')\n        .appendField('', 'SPACE');\n    this.appendDummyInput('AT');\n    if (Blockly.Msg.LISTS_GET_INDEX_TAIL) {\n      this.appendDummyInput('TAIL')\n          .appendField(Blockly.Msg.LISTS_GET_INDEX_TAIL);\n    }\n    this.setInputsInline(true);\n    this.setOutput(true);\n    this.updateAt_(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var combo = thisBlock.getFieldValue('MODE') + '_' +\n          thisBlock.getFieldValue('WHERE');\n      return Blockly.Msg['LISTS_GET_INDEX_TOOLTIP_' + combo];\n    });\n  },\n  /**\n   * Create XML to represent whether the block is a statement or a value.\n   * Also represent whether there is an 'AT' input.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var isStatement = !this.outputConnection;\n    container.setAttribute('statement', isStatement);\n    var isAt = this.getInput('AT').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at', isAt);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'AT' input.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    // Note: Until January 2013 this block did not have mutations,\n    // so 'statement' defaults to false and 'at' defaults to true.\n    var isStatement = (xmlElement.getAttribute('statement') == 'true');\n    this.updateStatement_(isStatement);\n    var isAt = (xmlElement.getAttribute('at') != 'false');\n    this.updateAt_(isAt);\n  },\n  /**\n   * Switch between a value block and a statement block.\n   * @param {boolean} newStatement True if the block should be a statement.\n   *     False if the block should be a value.\n   * @private\n   * @this Blockly.Block\n   */\n  updateStatement_: function(newStatement) {\n    var oldStatement = !this.outputConnection;\n    if (newStatement != oldStatement) {\n      this.unplug(true, true);\n      if (newStatement) {\n        this.setOutput(false);\n        this.setPreviousStatement(true);\n        this.setNextStatement(true);\n      } else {\n        this.setPreviousStatement(false);\n        this.setNextStatement(false);\n        this.setOutput(true);\n      }\n    }\n  },\n  /**\n   * Create or delete an input for the numeric index.\n   * @param {boolean} isAt True if the input should exist.\n   * @private\n   * @this Blockly.Block\n   */\n  updateAt_: function(isAt) {\n    // Destroy old 'AT' and 'ORDINAL' inputs.\n    this.removeInput('AT');\n    this.removeInput('ORDINAL', true);\n    // Create either a value 'AT' input or a dummy input.\n    if (isAt) {\n      this.appendValueInput('AT').setCheck('Number');\n      if (Blockly.Msg.ORDINAL_NUMBER_SUFFIX) {\n        this.appendDummyInput('ORDINAL')\n            .appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX);\n      }\n    } else {\n      this.appendDummyInput('AT');\n    }\n    var menu = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function(value) {\n      var newAt = (value == 'FROM_START') || (value == 'FROM_END');\n      // The 'isAt' variable is available due to this function being a closure.\n      if (newAt != isAt) {\n        var block = this.sourceBlock_;\n        block.updateAt_(newAt);\n        // This menu has been destroyed and replaced.  Update the replacement.\n        block.setFieldValue(value, 'WHERE');\n        return null;\n      }\n      return undefined;\n    });\n    this.getInput('AT').appendField(menu, 'WHERE');\n    if (Blockly.Msg.LISTS_GET_INDEX_TAIL) {\n      this.moveInputBefore('TAIL', null);\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_getSublist'] = function(block) {\n  // Get sublist.\n  var list = Blockly.Python.valueToCode(block, 'LIST',\n      Blockly.Python.ORDER_MEMBER) || '[]';\n  var where1 = block.getFieldValue('WHERE1');\n  var where2 = block.getFieldValue('WHERE2');\n  var at1 = Blockly.Python.valueToCode(block, 'AT1',\n      Blockly.Python.ORDER_ADDITIVE) || '1';\n  var at2 = Blockly.Python.valueToCode(block, 'AT2',\n      Blockly.Python.ORDER_ADDITIVE) || '1';\n  if (where1 == 'FIRST' || (where1 == 'FROM_START' && at1 == '1')) {\n    at1 = '';\n  } else if (where1 == 'FROM_START') {\n    // Blockly uses one-based indicies.\n    if (Blockly.isNumber(at1)) {\n      // If the index is a naked number, decrement it right now.\n      at1 = parseInt(at1, 10) - 1;\n    } else {\n      // If the index is dynamic, decrement it in code.\n      at1 = 'int(' + at1 + ' - 1)';\n    }\n  } else if (where1 == 'FROM_END') {\n    if (Blockly.isNumber(at1)) {\n      at1 = -parseInt(at1, 10);\n    } else {\n      at1 = '-int(' + at1 + ')';\n    }\n  }\n  if (where2 == 'LAST' || (where2 == 'FROM_END' && at2 == '1')) {\n    at2 = '';\n  } else if (where1 == 'FROM_START') {\n    if (Blockly.isNumber(at2)) {\n      at2 = parseInt(at2, 10);\n    } else {\n      at2 = 'int(' + at2 + ')';\n    }\n  } else if (where1 == 'FROM_END') {\n    if (Blockly.isNumber(at2)) {\n      // If the index is a naked number, increment it right now.\n      // Add special case for -0.\n      at2 = 1 - parseInt(at2, 10);\n      if (at2 == 0) {\n        at2 = '';\n      }\n    } else {\n      // If the index is dynamic, increment it in code.\n      Blockly.Python.definitions_['import_sys'] = 'import sys';\n      at2 = 'int(1 - ' + at2 + ') or sys.maxsize';\n    }\n  }\n  var code = list + '[' + at1 + ' : ' + at2 + ']';\n  return [code, Blockly.Python.ORDER_MEMBER];\n\n\n};",
      "name":"lists_getSublist",
      "structure":"Blockly.Blocks['lists_getSublist'] = {\n  /**\n   * Block for getting sublist.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this['WHERE_OPTIONS_1'] =\n        [[Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_START, 'FROM_START'],\n         [Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_END, 'FROM_END'],\n         [Blockly.Msg.LISTS_GET_SUBLIST_START_FIRST, 'FIRST']];\n    this['WHERE_OPTIONS_2'] =\n        [[Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_START, 'FROM_START'],\n         [Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_END, 'FROM_END'],\n         [Blockly.Msg.LISTS_GET_SUBLIST_END_LAST, 'LAST']];\n    this.setHelpUrl(Blockly.Msg.LISTS_GET_SUBLIST_HELPURL);\n    this.setColour(260);\n    this.appendValueInput('LIST')\n        .setCheck('Array')\n        .appendField(Blockly.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST);\n    this.appendDummyInput('AT1');\n    this.appendDummyInput('AT2');\n    if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {\n      this.appendDummyInput('TAIL')\n          .appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);\n    }\n    this.setInputsInline(true);\n    this.setOutput(true, 'Array');\n    this.updateAt_(1, true);\n    this.updateAt_(2, true);\n    this.setTooltip(Blockly.Msg.LISTS_GET_SUBLIST_TOOLTIP);\n  },\n  /**\n   * Create XML to represent whether there are 'AT' inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var isAt1 = this.getInput('AT1').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at1', isAt1);\n    var isAt2 = this.getInput('AT2').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at2', isAt2);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'AT' inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    var isAt1 = (xmlElement.getAttribute('at1') == 'true');\n    var isAt2 = (xmlElement.getAttribute('at2') == 'true');\n    this.updateAt_(1, isAt1);\n    this.updateAt_(2, isAt2);\n  },\n  /**\n   * Create or delete an input for a numeric index.\n   * This block has two such inputs, independant of each other.\n   * @param {number} n Specify first or second input (1 or 2).\n   * @param {boolean} isAt True if the input should exist.\n   * @private\n   * @this Blockly.Block\n   */\n  updateAt_: function(n, isAt) {\n    // Create or delete an input for the numeric index.\n    // Destroy old 'AT' and 'ORDINAL' inputs.\n    this.removeInput('AT' + n);\n    this.removeInput('ORDINAL' + n, true);\n    // Create either a value 'AT' input or a dummy input.\n    if (isAt) {\n      this.appendValueInput('AT' + n).setCheck('Number');\n      if (Blockly.Msg.ORDINAL_NUMBER_SUFFIX) {\n        this.appendDummyInput('ORDINAL' + n)\n            .appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX);\n      }\n    } else {\n      this.appendDummyInput('AT' + n);\n    }\n    var menu = new Blockly.FieldDropdown(this['WHERE_OPTIONS_' + n],\n        function(value) {\n      var newAt = (value == 'FROM_START') || (value == 'FROM_END');\n      // The 'isAt' variable is available due to this function being a closure.\n      if (newAt != isAt) {\n        var block = this.sourceBlock_;\n        block.updateAt_(n, newAt);\n        // This menu has been destroyed and replaced.  Update the replacement.\n        block.setFieldValue(value, 'WHERE' + n);\n        return null;\n      }\n      return undefined;\n    });\n    this.getInput('AT' + n)\n        .appendField(menu, 'WHERE' + n);\n    if (n == 1) {\n      this.moveInputBefore('AT1', 'AT2');\n      if (this.getInput('ORDINAL1')) {\n        this.moveInputBefore('ORDINAL1', 'AT2');\n      }\n    }\n    if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {\n      this.moveInputBefore('TAIL', null);\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_indexOf'] = function(block) {\n  // Find an item in the list.\n  var argument0 = Blockly.Python.valueToCode(block, 'FIND',\n      Blockly.Python.ORDER_NONE) || '[]';\n  var argument1 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  var code;\n  if (block.getFieldValue('END') == 'FIRST') {\n    var functionName = Blockly.Python.provideFunction_(\n        'first_index',\n        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList, elem):',\n         '  try: theIndex = myList.index(elem) + 1',\n         '  except: theIndex = 0',\n         '  return theIndex']);\n    code = functionName + '(' + argument1 + ', ' + argument0 + ')';\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  } else {\n    var functionName = Blockly.Python.provideFunction_(\n        'last_index',\n        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList, elem):',\n         '  try: theIndex = len(myList) - myList[::-1].index(elem)',\n         '  except: theIndex = 0',\n         '  return theIndex']);\n    code = functionName + '(' + argument1 + ', ' + argument0 + ')';\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  }\n\n\n};",
      "name":"lists_indexOf",
      "structure":"Blockly.Blocks['lists_indexOf'] = {\n  /**\n   * Block for finding an item in the list.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.LISTS_INDEX_OF_FIRST, 'FIRST'],\n         [Blockly.Msg.LISTS_INDEX_OF_LAST, 'LAST']];\n    this.setHelpUrl(Blockly.Msg.LISTS_INDEX_OF_HELPURL);\n    this.setColour(260);\n    this.setOutput(true, 'Number');\n    this.appendValueInput('VALUE')\n        .setCheck('Array')\n        .appendField(Blockly.Msg.LISTS_INDEX_OF_INPUT_IN_LIST);\n    this.appendValueInput('FIND')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'END');\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.LISTS_INDEX_OF_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_isEmpty'] = function(block) {\n  // Is the list empty?\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '[]';\n  var code = 'not len(' + argument0 + ')';\n  return [code, Blockly.Python.ORDER_LOGICAL_NOT];\n\n\n};",
      "name":"lists_isEmpty",
      "structure":"Blockly.Blocks['lists_isEmpty'] = {\n  /**\n   * Block for is the list empty?\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LISTS_IS_EMPTY_HELPURL);\n    this.setColour(260);\n    this.interpolateMsg(Blockly.Msg.LISTS_IS_EMPTY_TITLE,\n                        ['VALUE', ['Array', 'String'], Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setInputsInline(true);\n    this.setOutput(true, 'Boolean');\n    this.setTooltip(Blockly.Msg.LISTS_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_length'] = function(block) {\n  // List length.\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '[]';\n  return ['len(' + argument0 + ')', Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"lists_length",
      "structure":"Blockly.Blocks['lists_length'] = {\n  /**\n   * Block for list length.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LISTS_LENGTH_HELPURL);\n    this.setColour(260);\n    this.interpolateMsg(Blockly.Msg.LISTS_LENGTH_TITLE,\n                        ['VALUE', ['Array', 'String'], Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setOutput(true, 'Number');\n    this.setTooltip(Blockly.Msg.LISTS_LENGTH_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_repeat'] = function(block) {\n  // Create a list with one element repeated.\n  var argument0 = Blockly.Python.valueToCode(block, 'ITEM',\n      Blockly.Python.ORDER_NONE) || 'None';\n  var argument1 = Blockly.Python.valueToCode(block, 'NUM',\n      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';\n  var code = '[' + argument0 + '] * ' + argument1;\n  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];\n\n\n};",
      "name":"lists_repeat",
      "structure":"Blockly.Blocks['lists_repeat'] = {\n  /**\n   * Block for creating a list with one element repeated.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LISTS_REPEAT_HELPURL);\n    this.setColour(260);\n    this.setOutput(true, 'Array');\n    this.interpolateMsg(Blockly.Msg.LISTS_REPEAT_TITLE,\n                        ['ITEM', null, Blockly.ALIGN_RIGHT],\n                        ['NUM', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setTooltip(Blockly.Msg.LISTS_REPEAT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_setIndex'] = function(block) {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  var list = Blockly.Python.valueToCode(block, 'LIST',\n      Blockly.Python.ORDER_MEMBER) || '[]';\n  var mode = block.getFieldValue('MODE') || 'GET';\n  var where = block.getFieldValue('WHERE') || 'FROM_START';\n  var at = Blockly.Python.valueToCode(block, 'AT',\n      Blockly.Python.ORDER_NONE) || '1';\n  var value = Blockly.Python.valueToCode(block, 'TO',\n      Blockly.Python.ORDER_NONE) || 'None';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  // Closure, which accesses and modifies 'list'.\n  function cacheList() {\n    if (list.match(/^\\w+$/)) {\n      return '';\n    }\n    var listVar = Blockly.Python.variableDB_.getDistinctName(\n        'tmp_list', Blockly.Variables.NAME_TYPE);\n    var code = listVar + ' = ' + list + '\\n';\n    list = listVar;\n    return code;\n  }\n  if (where == 'FIRST') {\n    if (mode == 'SET') {\n      return list + '[0] = ' + value + '\\n';\n    } else if (mode == 'INSERT') {\n      return list + '.insert(0, ' + value + ')\\n';\n    }\n  } else if (where == 'LAST') {\n    if (mode == 'SET') {\n      return list + '[-1] = ' + value + '\\n';\n    } else if (mode == 'INSERT') {\n      return list + '.append(' + value + ')\\n';\n    }\n  } else if (where == 'FROM_START') {\n    // Blockly uses one-based indicies.\n    if (Blockly.isNumber(at)) {\n      // If the index is a naked number, decrement it right now.\n      at = parseInt(at, 10) - 1;\n    } else {\n      // If the index is dynamic, decrement it in code.\n      at = 'int(' + at + ' - 1)';\n    }\n    if (mode == 'SET') {\n      return list + '[' + at + '] = ' + value + '\\n';\n    } else if (mode == 'INSERT') {\n      return list + '.insert(' + at + ', ' + value + ')\\n';\n    }\n  } else if (where == 'FROM_END') {\n    if (mode == 'SET') {\n      return list + '[-' + at + '] = ' + value + '\\n';\n    } else if (mode == 'INSERT') {\n      return list + '.insert(-' + at + ', ' + value + ')\\n';\n    }\n  } else if (where == 'RANDOM') {\n    Blockly.Python.definitions_['import_random'] = 'import random';\n    var code = cacheList();\n    var xVar = Blockly.Python.variableDB_.getDistinctName(\n        'tmp_x', Blockly.Variables.NAME_TYPE);\n    code += xVar + ' = int(random.random() * len(' + list + '))\\n';\n    if (mode == 'SET') {\n      code += list + '[' + xVar + '] = ' + value + '\\n';\n      return code;\n    } else if (mode == 'INSERT') {\n      code += list + '.insert(' + xVar + ', ' + value + ')\\n';\n      return code;\n    }\n  }\n  throw 'Unhandled combination (lists_setIndex).';\n\n\n};",
      "name":"lists_setIndex",
      "structure":"Blockly.Blocks['lists_setIndex'] = {\n  /**\n   * Block for setting the element at index.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var MODE =\n        [[Blockly.Msg.LISTS_SET_INDEX_SET, 'SET'],\n         [Blockly.Msg.LISTS_SET_INDEX_INSERT, 'INSERT']];\n    this.WHERE_OPTIONS =\n        [[Blockly.Msg.LISTS_GET_INDEX_FROM_START, 'FROM_START'],\n         [Blockly.Msg.LISTS_GET_INDEX_FROM_END, 'FROM_END'],\n         [Blockly.Msg.LISTS_GET_INDEX_FIRST, 'FIRST'],\n         [Blockly.Msg.LISTS_GET_INDEX_LAST, 'LAST'],\n         [Blockly.Msg.LISTS_GET_INDEX_RANDOM, 'RANDOM']];\n    this.setHelpUrl(Blockly.Msg.LISTS_SET_INDEX_HELPURL);\n    this.setColour(260);\n    this.appendValueInput('LIST')\n        .setCheck('Array')\n        .appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_IN_LIST);\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldDropdown(MODE), 'MODE')\n        .appendField('', 'SPACE');\n    this.appendDummyInput('AT');\n    this.appendValueInput('TO')\n        .appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_TO);\n    this.setInputsInline(true);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.LISTS_SET_INDEX_TOOLTIP);\n    this.updateAt_(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var combo = thisBlock.getFieldValue('MODE') + '_' +\n          thisBlock.getFieldValue('WHERE');\n      return Blockly.Msg['LISTS_SET_INDEX_TOOLTIP_' + combo];\n    });\n  },\n  /**\n   * Create XML to represent whether there is an 'AT' input.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var isAt = this.getInput('AT').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at', isAt);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'AT' input.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    // Note: Until January 2013 this block did not have mutations,\n    // so 'at' defaults to true.\n    var isAt = (xmlElement.getAttribute('at') != 'false');\n    this.updateAt_(isAt);\n  },\n  /**\n   * Create or delete an input for the numeric index.\n   * @param {boolean} isAt True if the input should exist.\n   * @private\n   * @this Blockly.Block\n   */\n  updateAt_: function(isAt) {\n    // Destroy old 'AT' and 'ORDINAL' input.\n    this.removeInput('AT');\n    this.removeInput('ORDINAL', true);\n    // Create either a value 'AT' input or a dummy input.\n    if (isAt) {\n      this.appendValueInput('AT').setCheck('Number');\n      if (Blockly.Msg.ORDINAL_NUMBER_SUFFIX) {\n        this.appendDummyInput('ORDINAL')\n            .appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX);\n      }\n    } else {\n      this.appendDummyInput('AT');\n    }\n    var menu = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function(value) {\n      var newAt = (value == 'FROM_START') || (value == 'FROM_END');\n      // The 'isAt' variable is available due to this function being a closure.\n      if (newAt != isAt) {\n        var block = this.sourceBlock_;\n        block.updateAt_(newAt);\n        // This menu has been destroyed and replaced.  Update the replacement.\n        block.setFieldValue(value, 'WHERE');\n        return null;\n      }\n      return undefined;\n    });\n    this.moveInputBefore('AT', 'TO');\n    if (this.getInput('ORDINAL')) {\n      this.moveInputBefore('ORDINAL', 'TO');\n    }\n\n    this.getInput('AT').appendField(menu, 'WHERE');\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['lists_split'] = function(block) {\n  // Block for splitting text into a list, or joining a list into text.\n  var mode = block.getFieldValue('MODE');\n  if (mode == 'SPLIT') {\n    var value_input = Blockly.Python.valueToCode(block, 'INPUT',\n        Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n    var value_delim = Blockly.Python.valueToCode(block, 'DELIM',\n        Blockly.Python.ORDER_NONE);\n    var code = value_input + '.split(' + value_delim + ')';\n  } else if (mode == 'JOIN') {\n    var value_input = Blockly.Python.valueToCode(block, 'INPUT',\n        Blockly.Python.ORDER_NONE) || '[]';\n    var value_delim = Blockly.Python.valueToCode(block, 'DELIM',\n        Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n    var code = value_delim + '.join(' + value_input + ')';\n  } else {\n    throw 'Unknown mode: ' + mode;\n  }\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n};",
      "name":"lists_split",
      "structure":"Blockly.Blocks['lists_split'] = {\n  /**\n   * Block for splitting text into a list, or joining a list into text.\n   * @this Blockly.Block\n   */\n  init: function() {\n    // Assign 'this' to a variable for use in the closures below.\n    var thisBlock = this;\n    var dropdown = new Blockly.FieldDropdown(\n        [[Blockly.Msg.LISTS_SPLIT_LIST_FROM_TEXT, 'SPLIT'],\n         [Blockly.Msg.LISTS_SPLIT_TEXT_FROM_LIST, 'JOIN']],\n        function(newOp) {\n          if (newOp == 'SPLIT') {\n            thisBlock.outputConnection.setCheck('Array');\n            thisBlock.getInput('INPUT').setCheck('String');\n          } else {\n            thisBlock.outputConnection.setCheck('String');\n            thisBlock.getInput('INPUT').setCheck('Array');\n          }\n        });\n    this.setHelpUrl(Blockly.Msg.LISTS_SPLIT_HELPURL);\n    this.setColour(260);\n    this.appendValueInput('INPUT')\n        .setCheck('String')\n        .appendField(dropdown, 'MODE');\n    this.appendValueInput('DELIM')\n        .setCheck('String')\n        .appendField(Blockly.Msg.LISTS_SPLIT_WITH_DELIMITER);\n    this.setInputsInline(true);\n    this.setOutput(true, 'Array');\n    this.setTooltip(function() {\n      var mode = thisBlock.getFieldValue('MODE');\n      if (mode == 'SPLIT') {\n        return Blockly.Msg.LISTS_SPLIT_TOOLTIP_SPLIT;\n      } else if (mode == 'JOIN') {\n        return Blockly.Msg.LISTS_SPLIT_TOOLTIP_JOIN;\n      }\n      throw 'Unknown mode: ' + mode;\n    });\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['logic_boolean'] = function(block) {\n  // Boolean values true and false.\n  var code = (block.getFieldValue('BOOL') == 'TRUE') ? 'True' : 'False';\n  return [code, Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"logic_boolean",
      "structure":"Blockly.Blocks['logic_boolean'] = {\n  /**\n   * Block for boolean data type: true and false.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var BOOLEANS =\n        [[Blockly.Msg.LOGIC_BOOLEAN_TRUE, 'TRUE'],\n         [Blockly.Msg.LOGIC_BOOLEAN_FALSE, 'FALSE']];\n    this.setHelpUrl(Blockly.Msg.LOGIC_BOOLEAN_HELPURL);\n    this.setColour(210);\n    this.setOutput(true, 'Boolean');\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldDropdown(BOOLEANS), 'BOOL');\n    this.setTooltip(Blockly.Msg.LOGIC_BOOLEAN_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['logic_compare'] = function(block) {\n  // Comparison operator.\n  var OPERATORS = {\n    'EQ': '==',\n    'NEQ': '!=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>='\n  };\n  var operator = OPERATORS[block.getFieldValue('OP')];\n  var order = Blockly.Python.ORDER_RELATIONAL;\n  var argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';\n  var code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n};\n",
      "name":"logic_compare",
      "structure":"Blockly.Blocks['logic_compare'] = {\n  /**\n   * Block for comparison operator.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS = this.RTL ? [\n          ['=', 'EQ'],\n          ['\\u2260', 'NEQ'],\n          ['>', 'LT'],\n          ['\\u2265', 'LTE'],\n          ['<', 'GT'],\n          ['\\u2264', 'GTE']\n        ] : [\n          ['=', 'EQ'],\n          ['\\u2260', 'NEQ'],\n          ['<', 'LT'],\n          ['\\u2264', 'LTE'],\n          ['>', 'GT'],\n          ['\\u2265', 'GTE']\n        ];\n    this.setHelpUrl(Blockly.Msg.LOGIC_COMPARE_HELPURL);\n    this.setColour(210);\n    this.setOutput(true, 'Boolean');\n    this.appendValueInput('A');\n    this.appendValueInput('B')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');\n    this.setInputsInline(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var op = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'EQ': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_EQ,\n        'NEQ': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_NEQ,\n        'LT': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_LT,\n        'LTE': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_LTE,\n        'GT': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_GT,\n        'GTE': Blockly.Msg.LOGIC_COMPARE_TOOLTIP_GTE\n      };\n      return TOOLTIPS[op];\n    });\n    this.prevBlocks_ = [null, null];\n  },\n  /**\n   * Called whenever anything on the workspace changes.\n   * Prevent mismatched types from being compared.\n   * @this Blockly.Block\n   */\n  onchange: function() {\n    if (!this.workspace) {\n      // Block has been deleted.\n      return;\n    }\n    var blockA = this.getInputTargetBlock('A');\n    var blockB = this.getInputTargetBlock('B');\n    // Kick blocks that existed prior to this change if they don't match.\n    if (blockA && blockB &&\n        !blockA.outputConnection.checkType_(blockB.outputConnection)) {\n      // Mismatch between two inputs.  Disconnect previous and bump it away.\n      for (var i = 0; i < this.prevBlocks_.length; i++) {\n        var block = this.prevBlocks_[i];\n        if (block === blockA || block === blockB) {\n          block.setParent(null);\n          block.bumpNeighbours_();\n        }\n      }\n    }\n    this.prevBlocks_[0] = blockA;\n    this.prevBlocks_[1] = blockB;\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['logic_negate'] = function(block) {\n  // Negation.\n  var argument0 = Blockly.Python.valueToCode(block, 'BOOL',\n      Blockly.Python.ORDER_LOGICAL_NOT) || 'True';\n  var code = 'not ' + argument0;\n  return [code, Blockly.Python.ORDER_LOGICAL_NOT];\n\n\n};",
      "name":"logic_negate",
      "structure":"Blockly.Blocks['logic_negate'] = {\n  /**\n   * Block for negation.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LOGIC_NEGATE_HELPURL);\n    this.setColour(210);\n    this.setOutput(true, 'Boolean');\n    this.interpolateMsg(Blockly.Msg.LOGIC_NEGATE_TITLE,\n                        ['BOOL', 'Boolean', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setTooltip(Blockly.Msg.LOGIC_NEGATE_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['logic_null'] = function(block) {\n  // Null data type.\n  return ['None', Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"logic_null",
      "structure":"Blockly.Blocks['logic_null'] = {\n  /**\n   * Block for null data type.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LOGIC_NULL_HELPURL);\n    this.setColour(210);\n    this.setOutput(true);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.LOGIC_NULL);\n    this.setTooltip(Blockly.Msg.LOGIC_NULL_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['logic_operation'] = function(block) {\n  // Operations 'and', 'or'.\n  var operator = (block.getFieldValue('OP') == 'AND') ? 'and' : 'or';\n  var order = (operator == 'and') ? Blockly.Python.ORDER_LOGICAL_AND :\n      Blockly.Python.ORDER_LOGICAL_OR;\n  var argument0 = Blockly.Python.valueToCode(block, 'A', order);\n  var argument1 = Blockly.Python.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'False';\n    argument1 = 'False';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    var defaultArgument = (operator == 'and') ? 'True' : 'False';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  var code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n\n\n};",
      "name":"logic_operation",
      "structure":"Blockly.Blocks['logic_operation'] = {\n  /**\n   * Block for logical operations: 'and', 'or'.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.LOGIC_OPERATION_AND, 'AND'],\n         [Blockly.Msg.LOGIC_OPERATION_OR, 'OR']];\n    this.setHelpUrl(Blockly.Msg.LOGIC_OPERATION_HELPURL);\n    this.setColour(210);\n    this.setOutput(true, 'Boolean');\n    this.appendValueInput('A')\n        .setCheck('Boolean');\n    this.appendValueInput('B')\n        .setCheck('Boolean')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');\n    this.setInputsInline(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var op = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'AND': Blockly.Msg.LOGIC_OPERATION_TOOLTIP_AND,\n        'OR': Blockly.Msg.LOGIC_OPERATION_TOOLTIP_OR\n      };\n      return TOOLTIPS[op];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['logic_ternary'] = function(block) {\n  // Ternary operator.\n  var value_if = Blockly.Python.valueToCode(block, 'IF',\n      Blockly.Python.ORDER_CONDITIONAL) || 'False';\n  var value_then = Blockly.Python.valueToCode(block, 'THEN',\n      Blockly.Python.ORDER_CONDITIONAL) || 'None';\n  var value_else = Blockly.Python.valueToCode(block, 'ELSE',\n      Blockly.Python.ORDER_CONDITIONAL) || 'None';\n  var code = value_then + ' if ' + value_if + ' else ' + value_else;\n  return [code, Blockly.Python.ORDER_CONDITIONAL];\n\n};",
      "name":"logic_ternary",
      "structure":"Blockly.Blocks['logic_ternary'] = {\n  /**\n   * Block for ternary operator.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.LOGIC_TERNARY_HELPURL);\n    this.setColour(210);\n    this.appendValueInput('IF')\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg.LOGIC_TERNARY_CONDITION);\n    this.appendValueInput('THEN')\n        .appendField(Blockly.Msg.LOGIC_TERNARY_IF_TRUE);\n    this.appendValueInput('ELSE')\n        .appendField(Blockly.Msg.LOGIC_TERNARY_IF_FALSE);\n    this.setOutput(true);\n    this.setTooltip(Blockly.Msg.LOGIC_TERNARY_TOOLTIP);\n    this.prevParentConnection_ = null;\n  },\n  /**\n   * Called whenever anything on the workspace changes.\n   * Prevent mismatched types.\n   * @this Blockly.Block\n   */\n  onchange: function() {\n    if (!this.workspace) {\n      // Block has been deleted.\n      return;\n    }\n    var blockA = this.getInputTargetBlock('THEN');\n    var blockB = this.getInputTargetBlock('ELSE');\n    var parentConnection = this.outputConnection.targetConnection;\n    // Kick blocks that existed prior to this change if they don't match.\n    if ((blockA || blockB) && parentConnection) {\n      for (var i = 0; i < 2; i++) {\n        var block = (i == 1) ? blockA : blockB;\n        if (block && !block.outputConnection.checkType_(parentConnection)) {\n          if (parentConnection === this.prevParentConnection_) {\n            this.setParent(null);\n            parentConnection.sourceBlock_.bumpNeighbours_();\n          } else {\n            block.setParent(null);\n            block.bumpNeighbours_();\n          }\n        }\n      }\n    }\n    this.prevParentConnection_ = parentConnection;\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_arithmetic'] = function(block) {\n  // Basic arithmetic operators, and power.\n  var OPERATORS = {\n    'ADD': [' + ', Blockly.Python.ORDER_ADDITIVE],\n    'MINUS': [' - ', Blockly.Python.ORDER_ADDITIVE],\n    'MULTIPLY': [' * ', Blockly.Python.ORDER_MULTIPLICATIVE],\n    'DIVIDE': [' / ', Blockly.Python.ORDER_MULTIPLICATIVE],\n    'POWER': [' ** ', Blockly.Python.ORDER_EXPONENTIATION]\n  };\n  var tuple = OPERATORS[block.getFieldValue('OP')];\n  var operator = tuple[0];\n  var order = tuple[1];\n  var argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';\n  var code = argument0 + operator + argument1;\n  return [code, order];\n  // In case of 'DIVIDE', division between integers returns different results\n  // in Python 2 and 3. However, is not an issue since Blockly does not\n  // guarantee identical results in all languages.  To do otherwise would\n  // require every operator to be wrapped in a function call.  This would kill\n  // legibility of the generated code.\n};",
      "name":"math_arithmetic",
      "structure":"Blockly.Blocks['math_arithmetic'] = {\n  /**\n   * Block for basic arithmetic operator.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.MATH_ADDITION_SYMBOL, 'ADD'],\n         [Blockly.Msg.MATH_SUBTRACTION_SYMBOL, 'MINUS'],\n         [Blockly.Msg.MATH_MULTIPLICATION_SYMBOL, 'MULTIPLY'],\n         [Blockly.Msg.MATH_DIVISION_SYMBOL, 'DIVIDE'],\n         [Blockly.Msg.MATH_POWER_SYMBOL, 'POWER']];\n    this.setHelpUrl(Blockly.Msg.MATH_ARITHMETIC_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.appendValueInput('A')\n        .setCheck('Number');\n    this.appendValueInput('B')\n        .setCheck('Number')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');\n    this.setInputsInline(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var mode = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'ADD': Blockly.Msg.MATH_ARITHMETIC_TOOLTIP_ADD,\n        'MINUS': Blockly.Msg.MATH_ARITHMETIC_TOOLTIP_MINUS,\n        'MULTIPLY': Blockly.Msg.MATH_ARITHMETIC_TOOLTIP_MULTIPLY,\n        'DIVIDE': Blockly.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE,\n        'POWER': Blockly.Msg.MATH_ARITHMETIC_TOOLTIP_POWER\n      };\n      return TOOLTIPS[mode];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['math_change'] = function(block) {\n  // Add to a variable in place.\n  var argument0 = Blockly.Python.valueToCode(block, 'DELTA',\n      Blockly.Python.ORDER_ADDITIVE) || '0';\n  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),\n      Blockly.Variables.NAME_TYPE);\n  return varName + ' = (' + varName + ' if type(' + varName +\n      ') in (int, float, long) else 0) + ' + argument0 + '\\n';\n\n\n};",
      "name":"math_change",
      "structure":"Blockly.Blocks['math_change'] = {\n  /**\n   * Block for adding to a variable in place.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_CHANGE_HELPURL);\n    this.setColour(230);\n    this.interpolateMsg(\n        // TODO: Combine these messages instead of using concatenation.\n        Blockly.Msg.MATH_CHANGE_TITLE_CHANGE + ' %1 ' +\n        Blockly.Msg.MATH_CHANGE_INPUT_BY + ' %2',\n        ['VAR', new Blockly.FieldVariable(Blockly.Msg.MATH_CHANGE_TITLE_ITEM)],\n        ['DELTA', 'Number', Blockly.ALIGN_RIGHT],\n        Blockly.ALIGN_RIGHT);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return Blockly.Msg.MATH_CHANGE_TOOLTIP.replace('%1',\n          thisBlock.getFieldValue('VAR'));\n    });\n  },\n  /**\n   * Return all variables referenced by this block.\n   * @return   List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_constant'] = function(block) {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  var CONSTANTS = {\n    'PI': ['math.pi', Blockly.Python.ORDER_MEMBER],\n    'E': ['math.e', Blockly.Python.ORDER_MEMBER],\n    'GOLDEN_RATIO': ['(1 + math.sqrt(5)) / 2',\n                     Blockly.Python.ORDER_MULTIPLICATIVE],\n    'SQRT2': ['math.sqrt(2)', Blockly.Python.ORDER_MEMBER],\n    'SQRT1_2': ['math.sqrt(1.0 / 2)', Blockly.Python.ORDER_MEMBER],\n    'INFINITY': ['float(\\'inf\\')', Blockly.Python.ORDER_ATOMIC]\n  };\n  var constant = block.getFieldValue('CONSTANT');\n  if (constant != 'INFINITY') {\n    Blockly.Python.definitions_['import_math'] = 'import math';\n  }\n  return CONSTANTS[constant];\n};",
      "name":"math_constant",
      "structure":"Blockly.Blocks['math_constant'] = {\n  /**\n   * Block for constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var CONSTANTS =\n        [['\\u03c0', 'PI'],\n         ['e', 'E'],\n         ['\\u03c6', 'GOLDEN_RATIO'],\n         ['sqrt(2)', 'SQRT2'],\n         ['sqrt(\\u00bd)', 'SQRT1_2'],\n         ['\\u221e', 'INFINITY']];\n    this.setHelpUrl(Blockly.Msg.MATH_CONSTANT_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldDropdown(CONSTANTS), 'CONSTANT');\n    this.setTooltip(Blockly.Msg.MATH_CONSTANT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_constrain'] = function(block) {\n  // Constrain a number between two limits.\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'LOW',\n      Blockly.Python.ORDER_NONE) || '0';\n  var argument2 = Blockly.Python.valueToCode(block, 'HIGH',\n      Blockly.Python.ORDER_NONE) || 'float(\\'inf\\')';\n  var code = 'min(max(' + argument0 + ', ' + argument1 + '), ' +\n      argument2 + ')';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"math_constrain",
      "structure":"Blockly.Blocks['math_constrain'] = {\n  /**\n   * Block for constraining a number between two limits.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_CONSTRAIN_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.interpolateMsg(Blockly.Msg.MATH_CONSTRAIN_TITLE,\n                        ['VALUE', 'Number', Blockly.ALIGN_RIGHT],\n                        ['LOW', 'Number', Blockly.ALIGN_RIGHT],\n                        ['HIGH', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.MATH_CONSTRAIN_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_modulo'] = function(block) {\n  // Remainder computation.\n  var argument0 = Blockly.Python.valueToCode(block, 'DIVIDEND',\n      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'DIVISOR',\n      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';\n  var code = argument0 + ' % ' + argument1;\n  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];\n\n\n};",
      "name":"math_modulo",
      "structure":"Blockly.Blocks['math_modulo'] = {\n  /**\n   * Block for remainder of a division.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_MODULO_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.interpolateMsg(Blockly.Msg.MATH_MODULO_TITLE,\n                        ['DIVIDEND', 'Number', Blockly.ALIGN_RIGHT],\n                        ['DIVISOR', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.MATH_MODULO_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_number'] = function(block) {\n  // Numeric value.\n  var code = parseFloat(block.getFieldValue('NUM'));\n  var order = code < 0 ? Blockly.Python.ORDER_UNARY_SIGN :\n              Blockly.Python.ORDER_ATOMIC;\n  return [code, order];\n\n\n};",
      "name":"math_number",
      "structure":"Blockly.Blocks['math_number'] = {\n  /**\n   * Block for numeric value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_NUMBER_HELPURL);\n    this.setColour(230);\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldTextInput('0',\n        Blockly.FieldTextInput.numberValidator), 'NUM');\n    this.setOutput(true, 'Number');\n    this.setTooltip(Blockly.Msg.MATH_NUMBER_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_number_property'] = function(block) {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  var number_to_check = Blockly.Python.valueToCode(block, 'NUMBER_TO_CHECK',\n      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';\n  var dropdown_property = block.getFieldValue('PROPERTY');\n  var code;\n  if (dropdown_property == 'PRIME') {\n    Blockly.Python.definitions_['import_math'] = 'import math';\n    var functionName = Blockly.Python.provideFunction_(\n        'math_isPrime',\n        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(n):',\n         '  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods',\n         '  # If n is not a number but a string, try parsing it.',\n         '  if type(n) not in (int, float, long):',\n         '    try:',\n         '      n = float(n)',\n         '    except:',\n         '      return False',\n         '  if n == 2 or n == 3:',\n         '    return True',\n         '  # False if n is negative, is 1, or not whole,' +\n             ' or if n is divisible by 2 or 3.',\n         '  if n <= 1 or n % 1 != 0 or n % 2 == 0 or n % 3 == 0:',\n         '    return False',\n         '  # Check all the numbers of form 6k +/- 1, up to sqrt(n).',\n         '  for x in range(6, int(math.sqrt(n)) + 2, 6):',\n         '    if n % (x - 1) == 0 or n % (x + 1) == 0:',\n         '      return False',\n         '  return True']);\n    code = functionName + '(' + number_to_check + ')';\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  }\n  switch (dropdown_property) {\n    case 'EVEN':\n      code = number_to_check + ' % 2 == 0';\n      break;\n    case 'ODD':\n      code = number_to_check + ' % 2 == 1';\n      break;\n    case 'WHOLE':\n      code = number_to_check + ' % 1 == 0';\n      break;\n    case 'POSITIVE':\n      code = number_to_check + ' > 0';\n      break;\n    case 'NEGATIVE':\n      code = number_to_check + ' < 0';\n      break;\n    case 'DIVISIBLE_BY':\n      var divisor = Blockly.Python.valueToCode(block, 'DIVISOR',\n          Blockly.Python.ORDER_MULTIPLICATIVE);\n      // If 'divisor' is some code that evals to 0, Python will raise an error.\n      if (!divisor || divisor == '0') {\n        return ['False', Blockly.Python.ORDER_ATOMIC];\n      }\n      code = number_to_check + ' % ' + divisor + ' == 0';\n      break;\n  }\n  return [code, Blockly.Python.ORDER_RELATIONAL];\n\n\n};",
      "name":"math_number_property",
      "structure":"Blockly.Blocks['math_number_property'] = {\n  /**\n   * Block for checking if a number is even, odd, prime, whole, positive,\n   * negative or if it is divisible by certain number.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var PROPERTIES =\n        [[Blockly.Msg.MATH_IS_EVEN, 'EVEN'],\n         [Blockly.Msg.MATH_IS_ODD, 'ODD'],\n         [Blockly.Msg.MATH_IS_PRIME, 'PRIME'],\n         [Blockly.Msg.MATH_IS_WHOLE, 'WHOLE'],\n         [Blockly.Msg.MATH_IS_POSITIVE, 'POSITIVE'],\n         [Blockly.Msg.MATH_IS_NEGATIVE, 'NEGATIVE'],\n         [Blockly.Msg.MATH_IS_DIVISIBLE_BY, 'DIVISIBLE_BY']];\n    this.setColour(230);\n    this.appendValueInput('NUMBER_TO_CHECK')\n        .setCheck('Number');\n    var dropdown = new Blockly.FieldDropdown(PROPERTIES, function(option) {\n      var divisorInput = (option == 'DIVISIBLE_BY');\n      this.sourceBlock_.updateShape_(divisorInput);\n    });\n    this.appendDummyInput()\n        .appendField(dropdown, 'PROPERTY');\n    this.setInputsInline(true);\n    this.setOutput(true, 'Boolean');\n    this.setTooltip(Blockly.Msg.MATH_IS_TOOLTIP);\n  },\n  /**\n   * Create XML to represent whether the 'divisorInput' should be present.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var divisorInput = (this.getFieldValue('PROPERTY') == 'DIVISIBLE_BY');\n    container.setAttribute('divisor_input', divisorInput);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'divisorInput'.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    var divisorInput = (xmlElement.getAttribute('divisor_input') == 'true');\n    this.updateShape_(divisorInput);\n  },\n  /**\n   * Modify this block to have (or not have) an input for 'is divisible by'.\n   * @param {boolean} divisorInput True if this block has a divisor input.\n   * @private\n   * @this Blockly.Block\n   */\n  updateShape_: function(divisorInput) {\n    // Add or remove a Value Input.\n    var inputExists = this.getInput('DIVISOR');\n    if (divisorInput) {\n      if (!inputExists) {\n        this.appendValueInput('DIVISOR')\n            .setCheck('Number');\n      }\n    } else if (inputExists) {\n      this.removeInput('DIVISOR');\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_on_list'] = function(block) {\n  // Math functions for lists.\n  var func = block.getFieldValue('OP');\n  var list = Blockly.Python.valueToCode(block, 'LIST',\n      Blockly.Python.ORDER_NONE) || '[]';\n  var code;\n  switch (func) {\n    case 'SUM':\n      code = 'sum(' + list + ')';\n      break;\n    case 'MIN':\n      code = 'min(' + list + ')';\n      break;\n    case 'MAX':\n      code = 'max(' + list + ')';\n      break;\n    case 'AVERAGE':\n      var functionName = Blockly.Python.provideFunction_(\n          'math_mean',\n          // This operation excludes null and values that aren't int or float:',\n          // math_mean([null, null, \"aString\", 1, 9]) == 5.0.',\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',\n           '  localList = [e for e in myList if type(e) in (int, float, long)]',\n           '  if not localList: return',\n           '  return float(sum(localList)) / len(localList)']);\n      code = functionName + '(' + list + ')';\n      break;\n    case 'MEDIAN':\n      var functionName = Blockly.Python.provideFunction_(\n          'math_median',\n          // This operation excludes null values:\n          // math_median([null, null, 1, 3]) == 2.0.\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',\n           '  localList = sorted([e for e in myList ' +\n               'if type(e) in (int, float, long)])',\n           '  if not localList: return',\n           '  if len(localList) % 2 == 0:',\n           '    return (localList[len(localList) / 2 - 1] + ' +\n               'localList[len(localList) / 2]) / 2.0',\n           '  else:',\n           '    return localList[(len(localList) - 1) / 2]']);\n      code = functionName + '(' + list + ')';\n      break;\n    case 'MODE':\n      var functionName = Blockly.Python.provideFunction_(\n          'math_modes',\n          // As a list of numbers can contain more than one mode,\n          // the returned result is provided as an array.\n          // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(some_list):',\n           '  modes = []',\n           '  # Using a lists of [item, count] to keep count rather than dict',\n           '  # to avoid \"unhashable\" errors when the counted item is ' +\n               'itself a list or dict.',\n           '  counts = []',\n           '  maxCount = 1',\n           '  for item in some_list:',\n           '    found = False',\n           '    for count in counts:',\n           '      if count[0] == item:',\n           '        count[1] += 1',\n           '        maxCount = max(maxCount, count[1])',\n           '        found = True',\n           '    if not found:',\n           '      counts.append([item, 1])',\n           '  for counted_item, item_count in counts:',\n           '    if item_count == maxCount:',\n           '      modes.append(counted_item)',\n           '  return modes']);\n      code = functionName + '(' + list + ')';\n      break;\n    case 'STD_DEV':\n      Blockly.Python.definitions_['import_math'] = 'import math';\n      var functionName = Blockly.Python.provideFunction_(\n          'math_standard_deviation',\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(numbers):',\n           '  n = len(numbers)',\n           '  if n == 0: return',\n           '  mean = float(sum(numbers)) / n',\n           '  variance = sum((x - mean) ** 2 for x in numbers) / n',\n           '  return math.sqrt(variance)']);\n      code = functionName + '(' + list + ')';\n      break;\n    case 'RANDOM':\n      Blockly.Python.definitions_['import_random'] = 'import random';\n      code = 'random.choice(' + list + ')';\n      break;\n    default:\n      throw 'Unknown operator: ' + func;\n  }\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n};",
      "name":"math_on_list",
      "structure":"Blockly.Blocks['math_on_list'] = {\n  /**\n   * Block for evaluating a list of numbers to return sum, average, min, max,\n   * etc.  Some functions also work on text (min, max, mode, median).\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.MATH_ONLIST_OPERATOR_SUM, 'SUM'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_MIN, 'MIN'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_MAX, 'MAX'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_AVERAGE, 'AVERAGE'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_MEDIAN, 'MEDIAN'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_MODE, 'MODE'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_STD_DEV, 'STD_DEV'],\n         [Blockly.Msg.MATH_ONLIST_OPERATOR_RANDOM, 'RANDOM']];\n    // Assign 'this' to a variable for use in the closures below.\n    var thisBlock = this;\n    this.setHelpUrl(Blockly.Msg.MATH_ONLIST_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    var dropdown = new Blockly.FieldDropdown(OPERATORS, function(newOp) {\n      if (newOp == 'MODE') {\n        thisBlock.outputConnection.setCheck('Array');\n      } else {\n        thisBlock.outputConnection.setCheck('Number');\n      }\n    });\n    this.appendValueInput('LIST')\n        .setCheck('Array')\n        .appendField(dropdown, 'OP');\n    this.setTooltip(function() {\n      var mode = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'SUM': Blockly.Msg.MATH_ONLIST_TOOLTIP_SUM,\n        'MIN': Blockly.Msg.MATH_ONLIST_TOOLTIP_MIN,\n        'MAX': Blockly.Msg.MATH_ONLIST_TOOLTIP_MAX,\n        'AVERAGE': Blockly.Msg.MATH_ONLIST_TOOLTIP_AVERAGE,\n        'MEDIAN': Blockly.Msg.MATH_ONLIST_TOOLTIP_MEDIAN,\n        'MODE': Blockly.Msg.MATH_ONLIST_TOOLTIP_MODE,\n        'STD_DEV': Blockly.Msg.MATH_ONLIST_TOOLTIP_STD_DEV,\n        'RANDOM': Blockly.Msg.MATH_ONLIST_TOOLTIP_RANDOM\n      };\n      return TOOLTIPS[mode];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['math_random_float'] = function(block) {\n  // Random fraction between 0 and 1.\n  Blockly.Python.definitions_['import_random'] = 'import random';\n  return ['random.random()', Blockly.Python.ORDER_FUNCTION_CALL];\n\n};",
      "name":"math_random_float",
      "structure":"Blockly.Blocks['math_random_float'] = {\n  /**\n   * Block for random fraction between 0 and 1.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_RANDOM_FLOAT_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.MATH_RANDOM_FLOAT_TITLE_RANDOM);\n    this.setTooltip(Blockly.Msg.MATH_RANDOM_FLOAT_TOOLTIP);\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_random_int'] = function(block) {\n  // Random integer between [X] and [Y].\n  Blockly.Python.definitions_['import_random'] = 'import random';\n  var argument0 = Blockly.Python.valueToCode(block, 'FROM',\n      Blockly.Python.ORDER_NONE) || '0';\n  var argument1 = Blockly.Python.valueToCode(block, 'TO',\n      Blockly.Python.ORDER_NONE) || '0';\n  var code = 'random.randint(' + argument0 + ', ' + argument1 + ')';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"math_random_int",
      "structure":"Blockly.Blocks['math_random_int'] = {\n  /**\n   * Block for random integer between [X] and [Y].\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.MATH_RANDOM_INT_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.interpolateMsg(Blockly.Msg.MATH_RANDOM_INT_TITLE,\n                        ['FROM', 'Number', Blockly.ALIGN_RIGHT],\n                        ['TO', 'Number', Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.MATH_RANDOM_INT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['math_single'] = function(block) {\n  // Math operators with single operand.\n  var operator = block.getFieldValue('OP');\n  var code;\n  var arg;\n  if (operator == 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    var code = Blockly.Python.valueToCode(block, 'NUM',\n        Blockly.Python.ORDER_UNARY_SIGN) || '0';\n    return ['-' + code, Blockly.Python.ORDER_UNARY_SIGN];\n  }\n  Blockly.Python.definitions_['import_math'] = 'import math';\n  if (operator == 'SIN' || operator == 'COS' || operator == 'TAN') {\n    arg = Blockly.Python.valueToCode(block, 'NUM',\n        Blockly.Python.ORDER_MULTIPLICATIVE) || '0';\n  } else {\n    arg = Blockly.Python.valueToCode(block, 'NUM',\n        Blockly.Python.ORDER_NONE) || '0';\n  }\n  // First, handle cases which generate values that don't need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'ABS':\n      code = 'math.fabs(' + arg + ')';\n      break;\n    case 'ROOT':\n      code = 'math.sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'math.log(' + arg + ')';\n      break;\n    case 'LOG10':\n      code = 'math.log10(' + arg + ')';\n      break;\n    case 'EXP':\n      code = 'math.exp(' + arg + ')';\n      break;\n    case 'POW10':\n      code = 'math.pow(10,' + arg + ')';\n      break;\n    case 'ROUND':\n      code = 'round(' + arg + ')';\n      break;\n    case 'ROUNDUP':\n      code = 'math.ceil(' + arg + ')';\n      break;\n    case 'ROUNDDOWN':\n      code = 'math.floor(' + arg + ')';\n      break;\n    case 'SIN':\n      code = 'math.sin(' + arg + ' / 180.0 * math.pi)';\n      break;\n    case 'COS':\n      code = 'math.cos(' + arg + ' / 180.0 * math.pi)';\n      break;\n    case 'TAN':\n      code = 'math.tan(' + arg + ' / 180.0 * math.pi)';\n      break;\n  }\n  if (code) {\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  }\n  // Second, handle cases which generate values that may need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'ASIN':\n      code = 'math.asin(' + arg + ') / math.pi * 180';\n      break;\n    case 'ACOS':\n      code = 'math.acos(' + arg + ') / math.pi * 180';\n      break;\n    case 'ATAN':\n      code = 'math.atan(' + arg + ') / math.pi * 180';\n      break;\n    default:\n      throw 'Unknown math operator: ' + operator;\n  }\n  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];\n};",
      "name":"math_single",
      "structure":"Blockly.Blocks['math_single'] = {\n  /**\n   * Block for advanced math operators with single operand.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.MATH_SINGLE_OP_ROOT, 'ROOT'],\n         [Blockly.Msg.MATH_SINGLE_OP_ABSOLUTE, 'ABS'],\n         ['-', 'NEG'],\n         ['ln', 'LN'],\n         ['log10', 'LOG10'],\n         ['e^', 'EXP'],\n         ['10^', 'POW10']];\n    this.setHelpUrl(Blockly.Msg.MATH_SINGLE_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.interpolateMsg('%1 %2',\n        ['OP', new Blockly.FieldDropdown(OPERATORS)],\n        ['NUM', 'Number', Blockly.ALIGN_RIGHT],\n        Blockly.ALIGN_RIGHT);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var mode = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'ROOT': Blockly.Msg.MATH_SINGLE_TOOLTIP_ROOT,\n        'ABS': Blockly.Msg.MATH_SINGLE_TOOLTIP_ABS,\n        'NEG': Blockly.Msg.MATH_SINGLE_TOOLTIP_NEG,\n        'LN': Blockly.Msg.MATH_SINGLE_TOOLTIP_LN,\n        'LOG10': Blockly.Msg.MATH_SINGLE_TOOLTIP_LOG10,\n        'EXP': Blockly.Msg.MATH_SINGLE_TOOLTIP_EXP,\n        'POW10': Blockly.Msg.MATH_SINGLE_TOOLTIP_POW10\n      };\n      return TOOLTIPS[mode];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['math_round'] = Blockly.Python['math_single'];",
      "name":"math_round",
      "structure":"Blockly.Blocks['math_round'] = {\n  /**\n   * Block for rounding functions.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.MATH_ROUND_OPERATOR_ROUND, 'ROUND'],\n         [Blockly.Msg.MATH_ROUND_OPERATOR_ROUNDUP, 'ROUNDUP'],\n         [Blockly.Msg.MATH_ROUND_OPERATOR_ROUNDDOWN, 'ROUNDDOWN']];\n    this.setHelpUrl(Blockly.Msg.MATH_ROUND_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.appendValueInput('NUM')\n        .setCheck('Number')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');\n    this.setTooltip(Blockly.Msg.MATH_ROUND_TOOLTIP);\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['math_trig'] = Blockly.Python['math_single'];",
      "name":"math_trig",
      "structure":"Blockly.Blocks['math_trig'] = {\n  /**\n   * Block for trigonometry operators.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.MATH_TRIG_SIN, 'SIN'],\n         [Blockly.Msg.MATH_TRIG_COS, 'COS'],\n         [Blockly.Msg.MATH_TRIG_TAN, 'TAN'],\n         [Blockly.Msg.MATH_TRIG_ASIN, 'ASIN'],\n         [Blockly.Msg.MATH_TRIG_ACOS, 'ACOS'],\n         [Blockly.Msg.MATH_TRIG_ATAN, 'ATAN']];\n    this.setHelpUrl(Blockly.Msg.MATH_TRIG_HELPURL);\n    this.setColour(230);\n    this.setOutput(true, 'Number');\n    this.appendValueInput('NUM')\n        .setCheck('Number')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      var mode = thisBlock.getFieldValue('OP');\n      var TOOLTIPS = {\n        'SIN': Blockly.Msg.MATH_TRIG_TOOLTIP_SIN,\n        'COS': Blockly.Msg.MATH_TRIG_TOOLTIP_COS,\n        'TAN': Blockly.Msg.MATH_TRIG_TOOLTIP_TAN,\n        'ASIN': Blockly.Msg.MATH_TRIG_TOOLTIP_ASIN,\n        'ACOS': Blockly.Msg.MATH_TRIG_TOOLTIP_ACOS,\n        'ATAN': Blockly.Msg.MATH_TRIG_TOOLTIP_ATAN\n      };\n      return TOOLTIPS[mode];\n    });\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['procedures_callnoreturn'] = function(block) {\n  // Call a procedure with no return value.\n  var funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'),\n      Blockly.Procedures.NAME_TYPE);\n  var args = [];\n  for (var x = 0; x < block.arguments_.length; x++) {\n    args[x] = Blockly.Python.valueToCode(block, 'ARG' + x,\n        Blockly.Python.ORDER_NONE) || 'None';\n  }\n  var code = funcName + '(' + args.join(', ') + ')\\n';\n  return code;\n\n\n};",
      "name":"procedures_callnoreturn",
      "structure":"Blockly.Blocks['procedures_callnoreturn'] = {\n  /**\n   * Block for calling a procedure with no return value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLNORETURN_HELPURL);\n    this.setColour(290);\n    this.appendDummyInput('TOPROW')\n        .appendField(Blockly.Msg.PROCEDURES_CALLNORETURN_CALL)\n        .appendField('', 'NAME');\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    // Tooltip is set in domToMutation.\n    this.arguments_ = [];\n    this.quarkConnections_ = {};\n    this.quarkArguments_ = null;\n  },\n  /**\n   * Returns the name of the procedure this block calls.\n   * @return {string} Procedure name.\n   * @this Blockly.Block\n   */\n  getProcedureCall: function() {\n    // The NAME field is guaranteed to exist, null will never be returned.\n    return /** @type {string} */ (this.getFieldValue('NAME'));\n  },\n  /**\n   * Notification that a procedure is renaming.\n   * If the name matches this block's procedure, rename it.\n   * @param {string} oldName Previous name of procedure.\n   * @param {string} newName Renamed procedure.\n   * @this Blockly.Block\n   */\n  renameProcedure: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getProcedureCall())) {\n      this.setFieldValue(newName, 'NAME');\n      this.setTooltip(\n          (this.outputConnection ? Blockly.Msg.PROCEDURES_CALLRETURN_TOOLTIP :\n           Blockly.Msg.PROCEDURES_CALLNORETURN_TOOLTIP)\n          .replace('%1', newName));\n    }\n  },\n  /**\n   * Notification that the procedure's parameters have changed.\n   * @param  paramNames New param names, e.g. ['x', 'y', 'z'].\n   * @param  paramIds IDs of params (consistent for each\n   *     parameter through the life of a mutator, regardless of param renaming),\n   *     e.g. ['piua', 'f8b_', 'oi.o'].\n   * @this Blockly.Block\n   */\n  setProcedureParameters: function(paramNames, paramIds) {\n    // Data structures:\n    // this.arguments = ['x', 'y']\n    //     Existing param names.\n    // this.quarkConnections_ {piua: null, f8b_: Blockly.Connection}\n    //     Look-up of paramIds to connections plugged into the call block.\n    // this.quarkArguments_ = ['piua', 'f8b_']\n    //     Existing param IDs.\n    // Note that quarkConnections_ may include IDs that no longer exist, but\n    // which might reappear if a param is reattached in the mutator.\n    if (!paramIds) {\n      // Reset the quarks (a mutator is about to open).\n      this.quarkConnections_ = {};\n      this.quarkArguments_ = null;\n      return;\n    }\n    if (goog.array.equals(this.arguments_, paramNames)) {\n      // No change.\n      this.quarkArguments_ = paramIds;\n      return;\n    }\n    this.setCollapsed(false);\n    if (paramIds.length != paramNames.length) {\n      throw 'Error: paramNames and paramIds must be the same length.';\n    }\n    if (!this.quarkArguments_) {\n      // Initialize tracking for this block.\n      this.quarkConnections_ = {};\n      if (paramNames.join('\\n') == this.arguments_.join('\\n')) {\n        // No change to the parameters, allow quarkConnections_ to be\n        // populated with the existing connections.\n        this.quarkArguments_ = paramIds;\n      } else {\n        this.quarkArguments_ = [];\n      }\n    }\n    // Switch off rendering while the block is rebuilt.\n    var savedRendered = this.rendered;\n    this.rendered = false;\n    // Update the quarkConnections_ with existing connections.\n    for (var i = this.arguments_.length - 1; i >= 0; i--) {\n      var input = this.getInput('ARG' + i);\n      if (input) {\n        var connection = input.connection.targetConnection;\n        this.quarkConnections_[this.quarkArguments_[i]] = connection;\n        // Disconnect all argument blocks and remove all inputs.\n        this.removeInput('ARG' + i);\n      }\n    }\n    // Rebuild the block's arguments.\n    this.arguments_ = [].concat(paramNames);\n    this.renderArgs_();\n    this.quarkArguments_ = paramIds;\n    // Reconnect any child blocks.\n    if (this.quarkArguments_) {\n      for (var i = 0; i < this.arguments_.length; i++) {\n        var input = this.getInput('ARG' + i);\n        var quarkName = this.quarkArguments_[i];\n        if (quarkName in this.quarkConnections_) {\n          var connection = this.quarkConnections_[quarkName];\n          if (!connection || connection.targetConnection ||\n              connection.sourceBlock_.workspace != this.workspace) {\n            // Block no longer exists or has been attached elsewhere.\n            delete this.quarkConnections_[quarkName];\n          } else {\n            input.connection.connect(connection);\n          }\n        }\n      }\n    }\n    // Restore rendering and show the changes.\n    this.rendered = savedRendered;\n    if (this.rendered) {\n      this.render();\n    }\n  },\n  /**\n   * Render the arguments.\n   * @this Blockly.Block\n   * @private\n   */\n  renderArgs_: function() {\n    for (var i = 0; i < this.arguments_.length; i++) {\n      var input = this.appendValueInput('ARG' + i)\n          .setAlign(Blockly.ALIGN_RIGHT)\n          .appendField(this.arguments_[i]);\n      input.init();\n    }\n    // Add 'with:' if there are parameters.\n    var input = this.getInput('TOPROW');\n    if (input) {\n      if (this.arguments_.length) {\n        if (!this.getField_('WITH')) {\n          input.appendField(Blockly.Msg.PROCEDURES_CALL_BEFORE_PARAMS, 'WITH');\n          input.init();\n        }\n      } else {\n        if (this.getField_('WITH')) {\n          input.removeField('WITH');\n        }\n      }\n    }\n  },\n  /**\n   * Create XML to represent the (non-editable) name and arguments.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    container.setAttribute('name', this.getProcedureCall());\n    for (var i = 0; i < this.arguments_.length; i++) {\n      var parameter = document.createElement('arg');\n      parameter.setAttribute('name', this.arguments_[i]);\n      container.appendChild(parameter);\n    }\n    return container;\n  },\n  /**\n   * Parse XML to restore the (non-editable) name and parameters.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    var name = xmlElement.getAttribute('name');\n    this.setFieldValue(name, 'NAME');\n    this.setTooltip(\n        (this.outputConnection ? Blockly.Msg.PROCEDURES_CALLRETURN_TOOLTIP :\n         Blockly.Msg.PROCEDURES_CALLNORETURN_TOOLTIP).replace('%1', name));\n    var def = Blockly.Procedures.getDefinition(name, this.workspace);\n    if (def && def.mutator && def.mutator.isVisible()) {\n      // Initialize caller with the mutator's IDs.\n      this.setProcedureParameters(def.arguments_, def.paramIds_);\n    } else {\n      var args = [];\n      for (var i = 0, childNode; childNode = xmlElement.childNodes[i]; i++) {\n        if (childNode.nodeName.toLowerCase() == 'arg') {\n          args.push(childNode.getAttribute('name'));\n        }\n      }\n      // For the second argument (paramIds) use the arguments list as a dummy\n      // list.\n      this.setProcedureParameters(args, args);\n    }\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    for (var i = 0; i < this.arguments_.length; i++) {\n      if (Blockly.Names.equals(oldName, this.arguments_[i])) {\n        this.arguments_[i] = newName;\n        this.getInput('ARG' + i).fieldRow[0].setText(newName);\n      }\n    }\n  },\n  /**\n   * Add menu option to find the definition block for this call.\n   * @param   options List of menu options to add to.\n   * @this Blockly.Block\n   */\n  customContextMenu: function(options) {\n    var option = {enabled: true};\n    option.text = Blockly.Msg.PROCEDURES_HIGHLIGHT_DEF;\n    var name = this.getProcedureCall();\n    var workspace = this.workspace;\n    option.callback = function() {\n      var def = Blockly.Procedures.getDefinition(name, workspace);\n      def && def.select();\n    };\n    options.push(option);\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['procedures_callreturn'] = function(block) {\n  // Call a procedure with a return value.\n  var funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'),\n      Blockly.Procedures.NAME_TYPE);\n  var args = [];\n  for (var x = 0; x < block.arguments_.length; x++) {\n    args[x] = Blockly.Python.valueToCode(block, 'ARG' + x,\n        Blockly.Python.ORDER_NONE) || 'None';\n  }\n  var code = funcName + '(' + args.join(', ') + ')';\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"procedures_callreturn",
      "structure":"Blockly.Blocks['procedures_callreturn'] = {\n  /**\n   * Block for calling a procedure with a return value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLRETURN_HELPURL);\n    this.setColour(290);\n    this.appendDummyInput('TOPROW')\n        .appendField(Blockly.Msg.PROCEDURES_CALLRETURN_CALL)\n        .appendField('', 'NAME');\n    this.setOutput(true);\n    // Tooltip is set in domToMutation.\n    this.arguments_ = [];\n    this.quarkConnections_ = {};\n    this.quarkArguments_ = null;\n  },\n  getProcedureCall: Blockly.Blocks['procedures_callnoreturn'].getProcedureCall,\n  renameProcedure: Blockly.Blocks['procedures_callnoreturn'].renameProcedure,\n  setProcedureParameters:\n      Blockly.Blocks['procedures_callnoreturn'].setProcedureParameters,\n  renderArgs_: Blockly.Blocks['procedures_callnoreturn'].renderArgs_,\n  mutationToDom: Blockly.Blocks['procedures_callnoreturn'].mutationToDom,\n  domToMutation: Blockly.Blocks['procedures_callnoreturn'].domToMutation,\n  renameVar: Blockly.Blocks['procedures_callnoreturn'].renameVar,\n  customContextMenu: Blockly.Blocks['procedures_callnoreturn'].customContextMenu\n};"
   },
   {
      "functionality":"Blockly.Python['procedures_defnoreturn'] =\n    Blockly.Python['procedures_defreturn'];",
      "name":"procedures_defnoreturn",
      "structure":"Blockly.Blocks['procedures_defnoreturn'] = {\n  /**\n   * Block for defining a procedure with no return value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFNORETURN_HELPURL);\n    this.setColour(290);\n    var name = Blockly.Procedures.findLegalName(\n        Blockly.Msg.PROCEDURES_DEFNORETURN_PROCEDURE, this);\n    var nameField = new Blockly.FieldTextInput(name,\n        Blockly.Procedures.rename);\n    nameField.setSpellcheck(false);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_TITLE)\n        .appendField(nameField, 'NAME')\n        .appendField('', 'PARAMS');\n    this.setMutator(new Blockly.Mutator(['procedures_mutatorarg']));\n    this.setTooltip(Blockly.Msg.PROCEDURES_DEFNORETURN_TOOLTIP);\n    this.arguments_ = [];\n    this.setStatements_(true);\n    this.statementConnection_ = null;\n  },\n  /**\n   * Add or remove the statement block from this function definition.\n   * @param {boolean} hasStatements True if a statement block is needed.\n   * @this Blockly.Block\n   */\n  setStatements_: function(hasStatements) {\n    if (this.hasStatements_ === hasStatements) {\n      return;\n    }\n    if (hasStatements) {\n      this.appendStatementInput('STACK')\n          .appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_DO);\n      if (this.getInput('RETURN')) {\n        this.moveInputBefore('STACK', 'RETURN');\n      }\n    } else {\n      this.removeInput('STACK', true);\n    }\n    this.hasStatements_ = hasStatements;\n  },\n  /**\n   * Update the display of parameters for this procedure definition block.\n   * Display a warning if there are duplicately named parameters.\n   * @private\n   * @this Blockly.Block\n   */\n  updateParams_: function() {\n    // Check for duplicated arguments.\n    var badArg = false;\n    var hash = {};\n    for (var i = 0; i < this.arguments_.length; i++) {\n      if (hash['arg_' + this.arguments_[i].toLowerCase()]) {\n        badArg = true;\n        break;\n      }\n      hash['arg_' + this.arguments_[i].toLowerCase()] = true;\n    }\n    if (badArg) {\n      this.setWarningText(Blockly.Msg.PROCEDURES_DEF_DUPLICATE_WARNING);\n    } else {\n      this.setWarningText(null);\n    }\n    // Merge the arguments into a human-readable list.\n    var paramString = '';\n    if (this.arguments_.length) {\n      paramString = Blockly.Msg.PROCEDURES_BEFORE_PARAMS +\n          ' ' + this.arguments_.join(', ');\n    }\n    this.setFieldValue(paramString, 'PARAMS');\n  },\n  /**\n   * Create XML to represent the argument inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    for (var i = 0; i < this.arguments_.length; i++) {\n      var parameter = document.createElement('arg');\n      parameter.setAttribute('name', this.arguments_[i]);\n      container.appendChild(parameter);\n    }\n\n    // Save whether the statement input is visible.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n    return container;\n  },\n  /**\n   * Parse XML to restore the argument inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    this.arguments_ = [];\n    for (var i = 0, childNode; childNode = xmlElement.childNodes[i]; i++) {\n      if (childNode.nodeName.toLowerCase() == 'arg') {\n        this.arguments_.push(childNode.getAttribute('name'));\n      }\n    }\n    this.updateParams_();\n\n    // Show or hide the statement input.\n    this.setStatements_(xmlElement.getAttribute('statements') !== 'false');\n  },\n  /**\n   * Populate the mutator's dialog with this block's components.\n   * @param {!Blockly.Workspace} workspace Mutator's workspace.\n   * @return {!Blockly.Block} Root block in mutator.\n   * @this Blockly.Block\n   */\n  decompose: function(workspace) {\n    var containerBlock = Blockly.Block.obtain(workspace,\n                                              'procedures_mutatorcontainer');\n    containerBlock.initSvg();\n\n    // Check/uncheck the allow statement box.\n    if (this.getInput('RETURN')) {\n      containerBlock.setFieldValue(this.hasStatements_ ? 'TRUE' : 'FALSE',\n                                   'STATEMENTS');\n    } else {\n      containerBlock.getInput('STATEMENT_INPUT').setVisible(false);\n    }\n\n    // Parameter list.\n    var connection = containerBlock.getInput('STACK').connection;\n    for (var i = 0; i < this.arguments_.length; i++) {\n      var paramBlock = Blockly.Block.obtain(workspace, 'procedures_mutatorarg');\n      paramBlock.initSvg();\n      paramBlock.setFieldValue(this.arguments_[i], 'NAME');\n      // Store the old location.\n      paramBlock.oldLocation = i;\n      connection.connect(paramBlock.previousConnection);\n      connection = paramBlock.nextConnection;\n    }\n    // Initialize procedure's callers with blank IDs.\n    Blockly.Procedures.mutateCallers(this.getFieldValue('NAME'),\n                                     this.workspace, this.arguments_, null);\n    return containerBlock;\n  },\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  compose: function(containerBlock) {\n    // Parameter list.\n    this.arguments_ = [];\n    this.paramIds_ = [];\n    var paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock) {\n      this.arguments_.push(paramBlock.getFieldValue('NAME'));\n      this.paramIds_.push(paramBlock.id);\n      paramBlock = paramBlock.nextConnection &&\n          paramBlock.nextConnection.targetBlock();\n    }\n    this.updateParams_();\n    Blockly.Procedures.mutateCallers(this.getFieldValue('NAME'),\n        this.workspace, this.arguments_, this.paramIds_);\n\n    // Show/hide the statement input.\n    var hasStatements = containerBlock.getFieldValue('STATEMENTS');\n    if (hasStatements !== null) {\n      hasStatements = hasStatements == 'TRUE';\n      if (this.hasStatements_ != hasStatements) {\n        if (hasStatements) {\n          this.setStatements_(true);\n          // Restore the stack, if one was saved.\n          var stackConnection = this.getInput('STACK').connection;\n          if (stackConnection.targetConnection ||\n              !this.statementConnection_ ||\n              this.statementConnection_.targetConnection ||\n              this.statementConnection_.sourceBlock_.workspace !=\n              this.workspace) {\n            // Block no longer exists or has been attached elsewhere.\n            this.statementConnection_ = null;\n          } else {\n            stackConnection.connect(this.statementConnection_);\n          }\n        } else {\n          // Save the stack, then disconnect it.\n          var stackConnection = this.getInput('STACK').connection;\n          this.statementConnection_ = stackConnection.targetConnection;\n          if (this.statementConnection_) {\n            var stackBlock = stackConnection.targetBlock();\n            stackBlock.setParent(null);\n            stackBlock.bumpNeighbours_();\n          }\n          this.setStatements_(false);\n        }\n      }\n    }\n  },\n  /**\n   * Dispose of any callers.\n   * @this Blockly.Block\n   */\n  dispose: function() {\n    var name = this.getFieldValue('NAME');\n    Blockly.Procedures.disposeCallers(name, this.workspace);\n    // Call parent's destructor.\n    this.constructor.prototype.dispose.apply(this, arguments);\n  },\n  /**\n   * Return the signature of this procedure definition.\n   * @return   Tuple containing three elements:\n   *     - the name of the defined procedure,\n   *     - a list of all its arguments,\n   *     - that it DOES NOT have a return value.\n   * @this Blockly.Block\n   */\n  getProcedureDef: function() {\n    return [this.getFieldValue('NAME'), this.arguments_, false];\n  },\n  /**\n   * Return all variables referenced by this block.\n   *  List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return this.arguments_;\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    var change = false;\n    for (var i = 0; i < this.arguments_.length; i++) {\n      if (Blockly.Names.equals(oldName, this.arguments_[i])) {\n        this.arguments_[i] = newName;\n        change = true;\n      }\n    }\n    if (change) {\n      this.updateParams_();\n      // Update the mutator's variables if the mutator is open.\n      if (this.mutator.isVisible()) {\n        var blocks = this.mutator.workspace_.getAllBlocks();\n        for (var i = 0, block; block = blocks[i]; i++) {\n          if (block.type == 'procedures_mutatorarg' &&\n              Blockly.Names.equals(oldName, block.getFieldValue('NAME'))) {\n            block.setFieldValue(newName, 'NAME');\n          }\n        }\n      }\n    }\n  },\n  /**\n   * Add custom menu options to this block's context menu.\n   * @param   options List of menu options to add to.\n   * @this Blockly.Block\n   */\n  customContextMenu: function(options) {\n    // Add option to create caller.\n    var option = {enabled: true};\n    var name = this.getFieldValue('NAME');\n    option.text = Blockly.Msg.PROCEDURES_CREATE_DO.replace('%1', name);\n    var xmlMutation = goog.dom.createDom('mutation');\n    xmlMutation.setAttribute('name', name);\n    for (var i = 0; i < this.arguments_.length; i++) {\n      var xmlArg = goog.dom.createDom('arg');\n      xmlArg.setAttribute('name', this.arguments_[i]);\n      xmlMutation.appendChild(xmlArg);\n    }\n    var xmlBlock = goog.dom.createDom('block', null, xmlMutation);\n    xmlBlock.setAttribute('type', this.callType_);\n    option.callback = Blockly.ContextMenu.callbackFactory(this, xmlBlock);\n    options.push(option);\n\n    // Add options to create getters for each parameter.\n    if (!this.isCollapsed()) {\n      for (var i = 0; i < this.arguments_.length; i++) {\n        var option = {enabled: true};\n        var name = this.arguments_[i];\n        option.text = Blockly.Msg.VARIABLES_SET_CREATE_GET.replace('%1', name);\n        var xmlField = goog.dom.createDom('field', null, name);\n        xmlField.setAttribute('name', 'VAR');\n        var xmlBlock = goog.dom.createDom('block', null, xmlField);\n        xmlBlock.setAttribute('type', 'variables_get');\n        option.callback = Blockly.ContextMenu.callbackFactory(this, xmlBlock);\n        options.push(option);\n      }\n    }\n  },\n  callType_: 'procedures_callnoreturn'\n};"
   },
   {
      "functionality":"Blockly.Python['procedures_defreturn'] = function(block) {\n  // Define a procedure with a return value.\n  // First, add a 'global' statement for every variable that is assigned.\n  var globals = Blockly.Variables.allVariables(block);\n  for (var i = globals.length - 1; i >= 0; i--) {\n    var varName = globals[i];\n    if (block.arguments_.indexOf(varName) == -1) {\n      globals[i] = Blockly.Python.variableDB_.getName(varName,\n          Blockly.Variables.NAME_TYPE);\n    } else {\n      // This variable is actually a parameter name.  Do not include it in\n      // the list of globals, thus allowing it be of local scope.\n      globals.splice(i, 1);\n    }\n  }\n  globals = globals.length ? '  global ' + globals.join(', ') + '\\n' : '';\n  var funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'),\n      Blockly.Procedures.NAME_TYPE);\n  var branch = Blockly.Python.statementToCode(block, 'STACK');\n  if (Blockly.Python.STATEMENT_PREFIX) {\n    branch = Blockly.Python.prefixLines(\n        Blockly.Python.STATEMENT_PREFIX.replace(/%1/g,\n        '\\'' + block.id + '\\''), Blockly.Python.INDENT) + branch;\n  }\n  if (Blockly.Python.INFINITE_LOOP_TRAP) {\n    branch = Blockly.Python.INFINITE_LOOP_TRAP.replace(/%1/g,\n        '\"' + block.id + '\"') + branch;\n  }\n  var returnValue = Blockly.Python.valueToCode(block, 'RETURN',\n      Blockly.Python.ORDER_NONE) || '';\n  if (returnValue) {\n    returnValue = '  return ' + returnValue + '\\n';\n  } else if (!branch) {\n    branch = Blockly.Python.PASS;\n  }\n  var args = [];\n  for (var x = 0; x < block.arguments_.length; x++) {\n    args[x] = Blockly.Python.variableDB_.getName(block.arguments_[x],\n        Blockly.Variables.NAME_TYPE);\n  }\n  var code = 'def ' + funcName + '(' + args.join(', ') + '):\\n' +\n      globals + branch + returnValue;\n  code = Blockly.Python.scrub_(block, code);\n  Blockly.Python.definitions_[funcName] = code;\n  return null;\n};",
      "name":"procedures_defreturn",
      "structure":"Blockly.Blocks['procedures_defreturn'] = {\n  /**\n   * Block for defining a procedure with a return value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFRETURN_HELPURL);\n    this.setColour(290);\n    var name = Blockly.Procedures.findLegalName(\n        Blockly.Msg.PROCEDURES_DEFRETURN_PROCEDURE, this);\n    var nameField = new Blockly.FieldTextInput(name,\n        Blockly.Procedures.rename);\n    nameField.setSpellcheck(false);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_TITLE)\n        .appendField(nameField, 'NAME')\n        .appendField('', 'PARAMS');\n    this.appendValueInput('RETURN')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);\n    this.setMutator(new Blockly.Mutator(['procedures_mutatorarg']));\n    this.setTooltip(Blockly.Msg.PROCEDURES_DEFRETURN_TOOLTIP);\n    this.arguments_ = [];\n    this.setStatements_(true);\n    this.statementConnection_ = null;\n  },\n  setStatements_: Blockly.Blocks['procedures_defnoreturn'].setStatements_,\n  updateParams_: Blockly.Blocks['procedures_defnoreturn'].updateParams_,\n  mutationToDom: Blockly.Blocks['procedures_defnoreturn'].mutationToDom,\n  domToMutation: Blockly.Blocks['procedures_defnoreturn'].domToMutation,\n  decompose: Blockly.Blocks['procedures_defnoreturn'].decompose,\n  compose: Blockly.Blocks['procedures_defnoreturn'].compose,\n  dispose: Blockly.Blocks['procedures_defnoreturn'].dispose,\n  /**\n   * Return the signature of this procedure definition.\n   * @return   Tuple containing three elements:\n   *     - the name of the defined procedure,\n   *     - a list of all its arguments,\n   *     - that it DOES have a return value.\n   * @this Blockly.Block\n   */\n  getProcedureDef: function() {\n    return [this.getFieldValue('NAME'), this.arguments_, true];\n  },\n  getVars: Blockly.Blocks['procedures_defnoreturn'].getVars,\n  renameVar: Blockly.Blocks['procedures_defnoreturn'].renameVar,\n  customContextMenu: Blockly.Blocks['procedures_defnoreturn'].customContextMenu,\n  callType_: 'procedures_callreturn'\n};"
   },
   {
      "functionality":"Blockly.Python['procedures_ifreturn'] = function(block) {\n  // Conditionally return value from a procedure.\n  var condition = Blockly.Python.valueToCode(block, 'CONDITION',\n      Blockly.Python.ORDER_NONE) || 'False';\n  var code = 'if ' + condition + ':\\n';\n  if (block.hasReturnValue_) {\n    var value = Blockly.Python.valueToCode(block, 'VALUE',\n        Blockly.Python.ORDER_NONE) || 'None';\n    code += '  return ' + value + '\\n';\n  } else {\n    code += '  return\\n';\n  }\n  return code;\n\n};",
      "name":"procedures_ifreturn",
      "structure":"Blockly.Blocks['procedures_ifreturn'] = {\n  /**\n   * Block for conditionally returning a value from a procedure.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl('http://c2.com/cgi/wiki?GuardClause');\n    this.setColour(290);\n    this.appendValueInput('CONDITION')\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);\n    this.appendValueInput('VALUE')\n        .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);\n    this.setInputsInline(true);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.PROCEDURES_IFRETURN_TOOLTIP);\n    this.hasReturnValue_ = true;\n  },\n  /**\n   * Create XML to represent whether this block has a return value.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    container.setAttribute('value', Number(this.hasReturnValue_));\n    return container;\n  },\n  /**\n   * Parse XML to restore whether this block has a return value.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    var value = xmlElement.getAttribute('value');\n    this.hasReturnValue_ = (value == 1);\n    if (!this.hasReturnValue_) {\n      this.removeInput('VALUE');\n      this.appendDummyInput('VALUE')\n        .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);\n    }\n  },\n  /**\n   * Called whenever anything on the workspace changes.\n   * Add warning if this flow block is not nested inside a loop.\n   * @this Blockly.Block\n   */\n  onchange: function() {\n    if (!this.workspace) {\n      // Block has been deleted.\n      return;\n    }\n    var legal = false;\n    // Is the block nested in a procedure?\n    var block = this;\n    do {\n      if (block.type == 'procedures_defnoreturn' ||\n          block.type == 'procedures_defreturn') {\n        legal = true;\n        break;\n      }\n      block = block.getSurroundParent();\n    } while (block);\n    if (legal) {\n      // If needed, toggle whether this block has a return value.\n      if (block.type == 'procedures_defnoreturn' && this.hasReturnValue_) {\n        this.removeInput('VALUE');\n        this.appendDummyInput('VALUE')\n          .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);\n        this.hasReturnValue_ = false;\n      } else if (block.type == 'procedures_defreturn' &&\n                 !this.hasReturnValue_) {\n        this.removeInput('VALUE');\n        this.appendValueInput('VALUE')\n          .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);\n        this.hasReturnValue_ = true;\n      }\n      this.setWarningText(null);\n    } else {\n      this.setWarningText(Blockly.Msg.PROCEDURES_IFRETURN_WARNING);\n    }\n  }\n\n};"
   },
   {
      "functionality": "",
      "name":"procedures_mutatorarg",
      "structure":"Blockly.Blocks['procedures_mutatorarg'] = {\n  /**\n   * Mutator block for procedure argument.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(290);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.PROCEDURES_MUTATORARG_TITLE)\n        .appendField(new Blockly.FieldTextInput('x', this.validator_), 'NAME');\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORARG_TOOLTIP);\n    this.contextMenu = false;\n  },\n  /**\n   * Obtain a valid name for the procedure.\n   * Merge runs of whitespace.  Strip leading and trailing whitespace.\n   * Beyond this, all names are legal.\n   * @param {string} newVar User-supplied name.\n   * @return {?string} Valid name, or null if a name was not specified.\n   * @private\n   * @this Blockly.Block\n   */\n  validator_: function(newVar) {\n    newVar = newVar.replace(/[\\s\\xa0]+/g, ' ').replace(/^ | $/g, '');\n    return newVar || null;\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"procedures_mutatorcontainer",
      "structure":"Blockly.Blocks['procedures_mutatorcontainer'] = {\n  /**\n   * Mutator block for procedure container.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(290);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TITLE);\n    this.appendStatementInput('STACK');\n    this.appendDummyInput('STATEMENT_INPUT')\n        .appendField(Blockly.Msg.PROCEDURES_ALLOW_STATEMENTS)\n        .appendField(new Blockly.FieldCheckbox('TRUE'), 'STATEMENTS');\n    this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text'] = function(block) {\n  // Text value.\n  var code = Blockly.Python.quote_(block.getFieldValue('TEXT'));\n  return [code, Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"text",
      "structure":"Blockly.Blocks['text'] = {\n  /**\n   * Block for text value.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_TEXT_HELPURL);\n    this.setColour(160);\n    this.appendDummyInput()\n        .appendField(this.newQuote_(true))\n        .appendField(new Blockly.FieldTextInput(''), 'TEXT')\n        .appendField(this.newQuote_(false));\n    this.setOutput(true, 'String');\n    this.setTooltip(Blockly.Msg.TEXT_TEXT_TOOLTIP);\n  },\n  /**\n   * Create an image of an open or closed quote.\n   * @param {boolean} open True if open quote, false if closed.\n   * @return {!Blockly.FieldImage} The field image of the quote.\n   * @this Blockly.Block\n   * @private\n   */\n  newQuote_: function(open) {\n    if (open == this.RTL) {\n      var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';\n    } else {\n      var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';\n    }\n    return new Blockly.FieldImage(file, 12, 12, '\"');\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['text_append'] = function(block) {\n  // Append to a variable in place.\n  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),\n      Blockly.Variables.NAME_TYPE);\n  var argument0 = Blockly.Python.valueToCode(block, 'TEXT',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  return varName + ' = str(' + varName + ') + str(' + argument0 + ')\\n';\n\n\n};",
      "name":"text_append",
      "structure":"Blockly.Blocks['text_append'] = {\n  /**\n   * Block for appending to a variable in place.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_APPEND_HELPURL);\n    this.setColour(160);\n    this.appendValueInput('TEXT')\n        .appendField(Blockly.Msg.TEXT_APPEND_TO)\n        .appendField(new Blockly.FieldVariable(\n        Blockly.Msg.TEXT_APPEND_VARIABLE), 'VAR')\n        .appendField(Blockly.Msg.TEXT_APPEND_APPENDTEXT);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return Blockly.Msg.TEXT_APPEND_TOOLTIP.replace('%1',\n          thisBlock.getFieldValue('VAR'));\n    });\n  },\n  /**\n   * Return all variables referenced by this block.\n   * @return   List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_changeCase'] = function(block) {\n  // Change capitalization.\n  var OPERATORS = {\n    'UPPERCASE': '.upper()',\n    'LOWERCASE': '.lower()',\n    'TITLECASE': '.title()'\n  };\n  var operator = OPERATORS[block.getFieldValue('CASE')];\n  var argument0 = Blockly.Python.valueToCode(block, 'TEXT',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  var code = argument0 + operator;\n  return [code, Blockly.Python.ORDER_MEMBER];\n};",
      "name":"text_changeCase",
      "structure":"Blockly.Blocks['text_changeCase'] = {\n  /**\n   * Block for changing capitalization.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE, 'UPPERCASE'],\n         [Blockly.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE, 'LOWERCASE'],\n         [Blockly.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE, 'TITLECASE']];\n    this.setHelpUrl(Blockly.Msg.TEXT_CHANGECASE_HELPURL);\n    this.setColour(160);\n    this.appendValueInput('TEXT')\n        .setCheck('String')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'CASE');\n    this.setOutput(true, 'String');\n    this.setTooltip(Blockly.Msg.TEXT_CHANGECASE_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_charAt'] = function(block) {\n  // Get letter at index.\n  // Note: Until January 2013 this block did not have the WHERE input.\n  var where = block.getFieldValue('WHERE') || 'FROM_START';\n  var at = Blockly.Python.valueToCode(block, 'AT',\n      Blockly.Python.ORDER_UNARY_SIGN) || '1';\n  var text = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  switch (where) {\n    case 'FIRST':\n      var code = text + '[0]';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    case 'LAST':\n      var code = text + '[-1]';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    case 'FROM_START':\n      // Blockly uses one-based indicies.\n      if (Blockly.isNumber(at)) {\n        // If the index is a naked number, decrement it right now.\n        at = parseInt(at, 10) - 1;\n      } else {\n        // If the index is dynamic, decrement it in code.\n        at = 'int(' + at + ' - 1)';\n      }\n      var code = text + '[' + at + ']';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    case 'FROM_END':\n      var code = text + '[-' + at + ']';\n      return [code, Blockly.Python.ORDER_MEMBER];\n    case 'RANDOM':\n      Blockly.Python.definitions_['import_random'] = 'import random';\n      var functionName = Blockly.Python.provideFunction_(\n          'text_random_letter',\n          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(text):',\n           '  x = int(random.random() * len(text))',\n           '  return text[x];']);\n      code = functionName + '(' + text + ')';\n      return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  }\n  throw 'Unhandled option (text_charAt).';\n\n\n};",
      "name":"text_charAt",
      "structure":"Blockly.Blocks['text_charAt'] = {\n  /**\n   * Block for getting a character from the string.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.WHERE_OPTIONS =\n        [[Blockly.Msg.TEXT_CHARAT_FROM_START, 'FROM_START'],\n         [Blockly.Msg.TEXT_CHARAT_FROM_END, 'FROM_END'],\n         [Blockly.Msg.TEXT_CHARAT_FIRST, 'FIRST'],\n         [Blockly.Msg.TEXT_CHARAT_LAST, 'LAST'],\n         [Blockly.Msg.TEXT_CHARAT_RANDOM, 'RANDOM']];\n    this.setHelpUrl(Blockly.Msg.TEXT_CHARAT_HELPURL);\n    this.setColour(160);\n    this.setOutput(true, 'String');\n    this.appendValueInput('VALUE')\n        .setCheck('String')\n        .appendField(Blockly.Msg.TEXT_CHARAT_INPUT_INTEXT);\n    this.appendDummyInput('AT');\n    this.setInputsInline(true);\n    this.updateAt_(true);\n    this.setTooltip(Blockly.Msg.TEXT_CHARAT_TOOLTIP);\n  },\n  /**\n   * Create XML to represent whether there is an 'AT' input.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var isAt = this.getInput('AT').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at', isAt);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'AT' input.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    // Note: Until January 2013 this block did not have mutations,\n    // so 'at' defaults to true.\n    var isAt = (xmlElement.getAttribute('at') != 'false');\n    this.updateAt_(isAt);\n  },\n  /**\n   * Create or delete an input for the numeric index.\n   * @param {boolean} isAt True if the input should exist.\n   * @private\n   * @this Blockly.Block\n   */\n  updateAt_: function(isAt) {\n    // Destroy old 'AT' and 'ORDINAL' inputs.\n    this.removeInput('AT');\n    this.removeInput('ORDINAL', true);\n    // Create either a value 'AT' input or a dummy input.\n    if (isAt) {\n      this.appendValueInput('AT').setCheck('Number');\n      if (Blockly.Msg.ORDINAL_NUMBER_SUFFIX) {\n        this.appendDummyInput('ORDINAL')\n            .appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX);\n      }\n    } else {\n      this.appendDummyInput('AT');\n    }\n    if (Blockly.Msg.TEXT_CHARAT_TAIL) {\n      this.removeInput('TAIL', true);\n      this.appendDummyInput('TAIL')\n          .appendField(Blockly.Msg.TEXT_CHARAT_TAIL);\n    }\n    var menu = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function(value) {\n      var newAt = (value == 'FROM_START') || (value == 'FROM_END');\n      // The 'isAt' variable is available due to this function being a closure.\n      if (newAt != isAt) {\n        var block = this.sourceBlock_;\n        block.updateAt_(newAt);\n        // This menu has been destroyed and replaced.  Update the replacement.\n        block.setFieldValue(value, 'WHERE');\n        return null;\n      }\n      return undefined;\n    });\n    this.getInput('AT').appendField(menu, 'WHERE');\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"text_create_join_container",
      "structure":"Blockly.Blocks['text_create_join_container'] = {\n  /**\n   * Mutator block for container.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(160);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.TEXT_CREATE_JOIN_TITLE_JOIN);\n    this.appendStatementInput('STACK');\n    this.setTooltip(Blockly.Msg.TEXT_CREATE_JOIN_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality": "",
      "name":"text_create_join_item",
      "structure":"Blockly.Blocks['text_create_join_item'] = {\n  /**\n   * Mutator block for add items.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setColour(160);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.TEXT_CREATE_JOIN_ITEM_TITLE_ITEM);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.TEXT_CREATE_JOIN_ITEM_TOOLTIP);\n    this.contextMenu = false;\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_getSubstring'] = function(block) {\n  // Get substring.\n  var text = Blockly.Python.valueToCode(block, 'STRING',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  var where1 = block.getFieldValue('WHERE1');\n  var where2 = block.getFieldValue('WHERE2');\n  var at1 = Blockly.Python.valueToCode(block, 'AT1',\n      Blockly.Python.ORDER_ADDITIVE) || '1';\n  var at2 = Blockly.Python.valueToCode(block, 'AT2',\n      Blockly.Python.ORDER_ADDITIVE) || '1';\n  if (where1 == 'FIRST' || (where1 == 'FROM_START' && at1 == '1')) {\n    at1 = '';\n  } else if (where1 == 'FROM_START') {\n    // Blockly uses one-based indicies.\n    if (Blockly.isNumber(at1)) {\n      // If the index is a naked number, decrement it right now.\n      at1 = parseInt(at1, 10) - 1;\n    } else {\n      // If the index is dynamic, decrement it in code.\n      at1 = 'int(' + at1 + ' - 1)';\n    }\n  } else if (where1 == 'FROM_END') {\n    if (Blockly.isNumber(at1)) {\n      at1 = -parseInt(at1, 10);\n    } else {\n      at1 = '-int(' + at1 + ')';\n    }\n  }\n  if (where2 == 'LAST' || (where2 == 'FROM_END' && at2 == '1')) {\n    at2 = '';\n  } else if (where1 == 'FROM_START') {\n    if (Blockly.isNumber(at2)) {\n      at2 = parseInt(at2, 10);\n    } else {\n      at2 = 'int(' + at2 + ')';\n    }\n  } else if (where1 == 'FROM_END') {\n    if (Blockly.isNumber(at2)) {\n      // If the index is a naked number, increment it right now.\n      at2 = 1 - parseInt(at2, 10);\n      if (at2 == 0) {\n        at2 = '';\n      }\n    } else {\n      // If the index is dynamic, increment it in code.\n      // Add special case for -0.\n      Blockly.Python.definitions_['import_sys'] = 'import sys';\n      at2 = 'int(1 - ' + at2 + ') or sys.maxsize';\n    }\n  }\n  var code = text + '[' + at1 + ' : ' + at2 + ']';\n  return [code, Blockly.Python.ORDER_MEMBER];\n\n\n};",
      "name":"text_getSubstring",
      "structure":"Blockly.Blocks['text_getSubstring'] = {\n  /**\n   * Block for getting substring.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this['WHERE_OPTIONS_1'] =\n        [[Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_START, 'FROM_START'],\n         [Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_END, 'FROM_END'],\n         [Blockly.Msg.TEXT_GET_SUBSTRING_START_FIRST, 'FIRST']];\n    this['WHERE_OPTIONS_2'] =\n        [[Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_START, 'FROM_START'],\n         [Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_END, 'FROM_END'],\n         [Blockly.Msg.TEXT_GET_SUBSTRING_END_LAST, 'LAST']];\n    this.setHelpUrl(Blockly.Msg.TEXT_GET_SUBSTRING_HELPURL);\n    this.setColour(160);\n    this.appendValueInput('STRING')\n        .setCheck('String')\n        .appendField(Blockly.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT);\n    this.appendDummyInput('AT1');\n    this.appendDummyInput('AT2');\n    if (Blockly.Msg.TEXT_GET_SUBSTRING_TAIL) {\n      this.appendDummyInput('TAIL')\n          .appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL);\n    }\n    this.setInputsInline(true);\n    this.setOutput(true, 'String');\n    this.updateAt_(1, true);\n    this.updateAt_(2, true);\n    this.setTooltip(Blockly.Msg.TEXT_GET_SUBSTRING_TOOLTIP);\n  },\n  /**\n   * Create XML to represent whether there are 'AT' inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    var isAt1 = this.getInput('AT1').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at1', isAt1);\n    var isAt2 = this.getInput('AT2').type == Blockly.INPUT_VALUE;\n    container.setAttribute('at2', isAt2);\n    return container;\n  },\n  /**\n   * Parse XML to restore the 'AT' inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    var isAt1 = (xmlElement.getAttribute('at1') == 'true');\n    var isAt2 = (xmlElement.getAttribute('at2') == 'true');\n    this.updateAt_(1, isAt1);\n    this.updateAt_(2, isAt2);\n  },\n  /**\n   * Create or delete an input for a numeric index.\n   * This block has two such inputs, independant of each other.\n   * @param {number} n Specify first or second input (1 or 2).\n   * @param {boolean} isAt True if the input should exist.\n   * @private\n   * @this Blockly.Block\n   */\n  updateAt_: function(n, isAt) {\n    // Create or delete an input for the numeric index.\n    // Destroy old 'AT' and 'ORDINAL' inputs.\n    this.removeInput('AT' + n);\n    this.removeInput('ORDINAL' + n, true);\n    // Create either a value 'AT' input or a dummy input.\n    if (isAt) {\n      this.appendValueInput('AT' + n).setCheck('Number');\n      if (Blockly.Msg.ORDINAL_NUMBER_SUFFIX) {\n        this.appendDummyInput('ORDINAL' + n)\n            .appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX);\n      }\n    } else {\n      this.appendDummyInput('AT' + n);\n    }\n    // Move tail, if present, to end of block.\n    if (n == 2 && Blockly.Msg.TEXT_GET_SUBSTRING_TAIL) {\n      this.removeInput('TAIL', true);\n      this.appendDummyInput('TAIL')\n          .appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL);\n    }\n    var menu = new Blockly.FieldDropdown(this['WHERE_OPTIONS_' + n],\n        function(value) {\n      var newAt = (value == 'FROM_START') || (value == 'FROM_END');\n      // The 'isAt' variable is available due to this function being a closure.\n      if (newAt != isAt) {\n        var block = this.sourceBlock_;\n        block.updateAt_(n, newAt);\n        // This menu has been destroyed and replaced.  Update the replacement.\n        block.setFieldValue(value, 'WHERE' + n);\n        return null;\n      }\n      return undefined;\n    });\n    this.getInput('AT' + n)\n        .appendField(menu, 'WHERE' + n);\n    if (n == 1) {\n      this.moveInputBefore('AT1', 'AT2');\n    }\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_indexOf'] = function(block) {\n  // Search the text for a substring.\n  // Should we allow for non-case sensitive???\n  var operator = block.getFieldValue('END') == 'FIRST' ? 'find' : 'rfind';\n  var argument0 = Blockly.Python.valueToCode(block, 'FIND',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  var argument1 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  var code = argument1 + '.' + operator + '(' + argument0 + ') + 1';\n  return [code, Blockly.Python.ORDER_MEMBER];\n\n\n};",
      "name":"text_indexOf",
      "structure":"Blockly.Blocks['text_indexOf'] = {\n  /**\n   * Block for finding a substring in the text.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.TEXT_INDEXOF_OPERATOR_FIRST, 'FIRST'],\n         [Blockly.Msg.TEXT_INDEXOF_OPERATOR_LAST, 'LAST']];\n    this.setHelpUrl(Blockly.Msg.TEXT_INDEXOF_HELPURL);\n    this.setColour(160);\n    this.setOutput(true, 'Number');\n    this.appendValueInput('VALUE')\n        .setCheck('String')\n        .appendField(Blockly.Msg.TEXT_INDEXOF_INPUT_INTEXT);\n    this.appendValueInput('FIND')\n        .setCheck('String')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'END');\n    if (Blockly.Msg.TEXT_INDEXOF_TAIL) {\n      this.appendDummyInput().appendField(Blockly.Msg.TEXT_INDEXOF_TAIL);\n    }\n    this.setInputsInline(true);\n    this.setTooltip(Blockly.Msg.TEXT_INDEXOF_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_isEmpty'] = function(block) {\n  // Is the string null?\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  var code = 'not len(' + argument0 + ')';\n  return [code, Blockly.Python.ORDER_LOGICAL_NOT];\n\n\n};",
      "name":"text_isEmpty",
      "structure":"Blockly.Blocks['text_isEmpty'] = {\n  /**\n   * Block for is the string null?\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_ISEMPTY_HELPURL);\n    this.setColour(160);\n    this.interpolateMsg(Blockly.Msg.TEXT_ISEMPTY_TITLE,\n                        ['VALUE', ['String', 'Array'], Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setOutput(true, 'Boolean');\n    this.setTooltip(Blockly.Msg.TEXT_ISEMPTY_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_join'] = function(block) {\n  // Create a string made up of any number of elements of any type.\n  //Should we allow joining by '-' or ',' or any other characters?\n  var code;\n  if (block.itemCount_ == 0) {\n    return ['\\'\\'', Blockly.Python.ORDER_ATOMIC];\n  } else if (block.itemCount_ == 1) {\n    var argument0 = Blockly.Python.valueToCode(block, 'ADD0',\n        Blockly.Python.ORDER_NONE) || '\\'\\'';\n    code = 'str(' + argument0 + ')';\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  } else if (block.itemCount_ == 2) {\n    var argument0 = Blockly.Python.valueToCode(block, 'ADD0',\n        Blockly.Python.ORDER_NONE) || '\\'\\'';\n    var argument1 = Blockly.Python.valueToCode(block, 'ADD1',\n        Blockly.Python.ORDER_NONE) || '\\'\\'';\n    var code = 'str(' + argument0 + ') + str(' + argument1 + ')';\n    return [code, Blockly.Python.ORDER_UNARY_SIGN];\n  } else {\n    var code = [];\n    for (var n = 0; n < block.itemCount_; n++) {\n      code[n] = Blockly.Python.valueToCode(block, 'ADD' + n,\n          Blockly.Python.ORDER_NONE) || '\\'\\'';\n    }\n    var tempVar = Blockly.Python.variableDB_.getDistinctName('temp_value',\n        Blockly.Variables.NAME_TYPE);\n    code = '\\'\\'.join([str(' + tempVar + ') for ' + tempVar + ' in [' +\n        code.join(', ') + ']])';\n    return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n  }\n\n\n};",
      "name":"text_join",
      "structure":"Blockly.Blocks['text_join'] = {\n  /**\n   * Block for creating a string made up of any number of elements of any type.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_JOIN_HELPURL);\n    this.setColour(160);\n    this.itemCount_ = 2;\n    this.updateShape_();\n    this.setOutput(true, 'String');\n    this.setMutator(new Blockly.Mutator(['text_create_join_item']));\n    this.setTooltip(Blockly.Msg.TEXT_JOIN_TOOLTIP);\n  },\n  /**\n   * Create XML to represent number of text inputs.\n   * @return {Element} XML storage element.\n   * @this Blockly.Block\n   */\n  mutationToDom: function() {\n    var container = document.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n  /**\n   * Parse XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this Blockly.Block\n   */\n  domToMutation: function(xmlElement) {\n    this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_();\n  },\n  /**\n   * Populate the mutator's dialog with this block's components.\n   * @param {!Blockly.Workspace} workspace Mutator's workspace.\n   * @return {!Blockly.Block} Root block in mutator.\n   * @this Blockly.Block\n   */\n  decompose: function(workspace) {\n    var containerBlock = Blockly.Block.obtain(workspace,\n                                           'text_create_join_container');\n    containerBlock.initSvg();\n    var connection = containerBlock.getInput('STACK').connection;\n    for (var i = 0; i < this.itemCount_; i++) {\n      var itemBlock = Blockly.Block.obtain(workspace, 'text_create_join_item');\n      itemBlock.initSvg();\n      connection.connect(itemBlock.previousConnection);\n      connection = itemBlock.nextConnection;\n    }\n    return containerBlock;\n  },\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  compose: function(containerBlock) {\n    var itemBlock = containerBlock.getInputTargetBlock('STACK');\n    // Count number of inputs.\n    var connections = [];\n    var i = 0;\n    while (itemBlock) {\n      connections[i] = itemBlock.valueConnection_;\n      itemBlock = itemBlock.nextConnection &&\n          itemBlock.nextConnection.targetBlock();\n      i++;\n    }\n    this.itemCount_ = i;\n    this.updateShape_();\n    // Reconnect any child blocks.\n    for (var i = 0; i < this.itemCount_; i++) {\n      if (connections[i]) {\n        this.getInput('ADD' + i).connection.connect(connections[i]);\n      }\n    }\n  },\n  /**\n   * Store pointers to any connected child blocks.\n   * @param {!Blockly.Block} containerBlock Root block in mutator.\n   * @this Blockly.Block\n   */\n  saveConnections: function(containerBlock) {\n    var itemBlock = containerBlock.getInputTargetBlock('STACK');\n    var i = 0;\n    while (itemBlock) {\n      var input = this.getInput('ADD' + i);\n      itemBlock.valueConnection_ = input && input.connection.targetConnection;\n      i++;\n      itemBlock = itemBlock.nextConnection &&\n          itemBlock.nextConnection.targetBlock();\n    }\n  },\n  /**\n   * Modify this block to have the correct number of inputs.\n   * @private\n   * @this Blockly.Block\n   */\n  updateShape_: function() {\n    // Delete everything.\n    if (this.getInput('EMPTY')) {\n      this.removeInput('EMPTY');\n    } else {\n      var i = 0;\n      while (this.getInput('ADD' + i)) {\n        this.removeInput('ADD' + i);\n        i++;\n      }\n    }\n    // Rebuild block.\n    if (this.itemCount_ == 0) {\n      this.appendDummyInput('EMPTY')\n          .appendField(this.newQuote_(true))\n          .appendField(this.newQuote_(false));\n    } else {\n      for (var i = 0; i < this.itemCount_; i++) {\n        var input = this.appendValueInput('ADD' + i);\n        if (i == 0) {\n          input.appendField(Blockly.Msg.TEXT_JOIN_TITLE_CREATEWITH);\n        }\n      }\n    }\n  },\n  newQuote_: Blockly.Blocks['text'].newQuote_\n};"
   },
   {
      "functionality":"Blockly.Python['text_length'] = function(block) {\n  // String length.\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  return ['len(' + argument0 + ')', Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"text_length",
      "structure":"Blockly.Blocks['text_length'] = {\n  /**\n   * Block for string length.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_LENGTH_HELPURL);\n    this.setColour(160);\n    this.interpolateMsg(Blockly.Msg.TEXT_LENGTH_TITLE,\n                        ['VALUE', ['String', 'Array'], Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setOutput(true, 'Number');\n    this.setTooltip(Blockly.Msg.TEXT_LENGTH_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_print'] = function(block) {\n  // Print statement.\n  var argument0 = Blockly.Python.valueToCode(block, 'TEXT',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  return 'print(' + argument0 + ')\\n';\n\n\n};",
      "name":"text_print",
      "structure":"Blockly.Blocks['text_print'] = {\n  /**\n   * Block for print statement.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.TEXT_PRINT_HELPURL);\n    this.setColour(160);\n    this.interpolateMsg(Blockly.Msg.TEXT_PRINT_TITLE,\n                        ['TEXT', null, Blockly.ALIGN_RIGHT],\n                        Blockly.ALIGN_RIGHT);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.TEXT_PRINT_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_prompt'] = function(block) {\n  // Prompt function (internal message).\n  var functionName = Blockly.Python.provideFunction_(\n      'text_prompt',\n      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(msg):',\n       '  try:',\n       '    return raw_input(msg)',\n       '  except NameError:',\n       '    return input(msg)']);\n  var msg = Blockly.Python.quote_(block.getFieldValue('TEXT'));\n  var code = functionName + '(' + msg + ')';\n  var toNumber = block.getFieldValue('TYPE') == 'NUMBER';\n  if (toNumber) {\n    code = 'float(' + code + ')';\n  }\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n\n};",
      "name":"text_prompt",
      "structure":"Blockly.Blocks['text_prompt'] = {\n  /**\n   * Block for prompt function (internal message).\n   * @this Blockly.Block\n   */\n  init: function() {\n    var TYPES =\n        [[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, 'TEXT'],\n         [Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, 'NUMBER']];\n    // Assign 'this' to a variable for use in the closure below.\n    var thisBlock = this;\n    this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);\n    this.setColour(160);\n    var dropdown = new Blockly.FieldDropdown(TYPES, function(newOp) {\n      if (newOp == 'NUMBER') {\n        thisBlock.changeOutput('Number');\n      } else {\n        thisBlock.changeOutput('String');\n      }\n    });\n    this.appendDummyInput()\n        .appendField(dropdown, 'TYPE')\n        .appendField(this.newQuote_(true))\n        .appendField(new Blockly.FieldTextInput(''), 'TEXT')\n        .appendField(this.newQuote_(false));\n    this.setOutput(true, 'String');\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return (thisBlock.getFieldValue('TYPE') == 'TEXT') ?\n          Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT :\n          Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER;\n    });\n  },\n  newQuote_: Blockly.Blocks['text'].newQuote_\n};"
   },
   {
      "functionality":"Blockly.Python['text_prompt_ext'] = function(block) {\n  // Prompt function (external message).\n  var functionName = Blockly.Python.provideFunction_(\n      'text_prompt',\n      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(msg):',\n       '  try:',\n       '    return raw_input(msg)',\n       '  except NameError:',\n       '    return input(msg)']);\n  var msg = Blockly.Python.valueToCode(block, 'TEXT',\n      Blockly.Python.ORDER_NONE) || '\\'\\'';\n  var code = functionName + '(' + msg + ')';\n  var toNumber = block.getFieldValue('TYPE') == 'NUMBER';\n  if (toNumber) {\n    code = 'float(' + code + ')';\n  }\n  return [code, Blockly.Python.ORDER_FUNCTION_CALL];\n\n};",
      "name":"text_prompt_ext",
      "structure":"Blockly.Blocks['text_prompt_ext'] = {\n  /**\n   * Block for prompt function (external message).\n   * @this Blockly.Block\n   */\n  init: function() {\n    var TYPES =\n        [[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, 'TEXT'],\n         [Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, 'NUMBER']];\n    // Assign 'this' to a variable for use in the closure below.\n    var thisBlock = this;\n    this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);\n    this.setColour(160);\n    var dropdown = new Blockly.FieldDropdown(TYPES, function(newOp) {\n      if (newOp == 'NUMBER') {\n        thisBlock.changeOutput('Number');\n      } else {\n        thisBlock.changeOutput('String');\n      }\n    });\n    this.appendValueInput('TEXT')\n        .appendField(dropdown, 'TYPE');\n    this.setOutput(true, 'String');\n    // Assign 'this' to a variable for use in the tooltip closure below.\n    var thisBlock = this;\n    this.setTooltip(function() {\n      return (thisBlock.getFieldValue('TYPE') == 'TEXT') ?\n          Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT :\n          Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER;\n    });\n  }\n\n};"
   },
   {
      "functionality":"Blockly.Python['text_trim'] = function(block) {\n  // Trim spaces.\n  var OPERATORS = {\n    'LEFT': '.lstrip()',\n    'RIGHT': '.rstrip()',\n    'BOTH': '.strip()'\n  };\n  var operator = OPERATORS[block.getFieldValue('MODE')];\n  var argument0 = Blockly.Python.valueToCode(block, 'TEXT',\n      Blockly.Python.ORDER_MEMBER) || '\\'\\'';\n  var code = argument0 + operator;\n  return [code, Blockly.Python.ORDER_MEMBER];\n};",
      "name":"text_trim",
      "structure":"Blockly.Blocks['text_trim'] = {\n  /**\n   * Block for trimming spaces.\n   * @this Blockly.Block\n   */\n  init: function() {\n    var OPERATORS =\n        [[Blockly.Msg.TEXT_TRIM_OPERATOR_BOTH, 'BOTH'],\n         [Blockly.Msg.TEXT_TRIM_OPERATOR_LEFT, 'LEFT'],\n         [Blockly.Msg.TEXT_TRIM_OPERATOR_RIGHT, 'RIGHT']];\n    this.setHelpUrl(Blockly.Msg.TEXT_TRIM_HELPURL);\n    this.setColour(160);\n    this.appendValueInput('TEXT')\n        .setCheck('String')\n        .appendField(new Blockly.FieldDropdown(OPERATORS), 'MODE');\n    this.setOutput(true, 'String');\n    this.setTooltip(Blockly.Msg.TEXT_TRIM_TOOLTIP);\n  }\n\n\n};"
   },
   {
      "functionality":"Blockly.Python['variables_get'] = function(block) {\n  // Variable getter.\n  var code = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),\n      Blockly.Variables.NAME_TYPE);\n  return [code, Blockly.Python.ORDER_ATOMIC];\n\n\n};",
      "name":"variables_get",
      "structure":"Blockly.Blocks['variables_get'] = {\n  /**\n   * Block for variable getter.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.VARIABLES_GET_HELPURL);\n    this.setColour(330);\n    this.appendDummyInput()\n        .appendField(Blockly.Msg.VARIABLES_GET_TITLE)\n        .appendField(new Blockly.FieldVariable(\n        Blockly.Msg.VARIABLES_GET_ITEM), 'VAR')\n        .appendField(Blockly.Msg.VARIABLES_GET_TAIL);\n    this.setOutput(true);\n    this.setTooltip(Blockly.Msg.VARIABLES_GET_TOOLTIP);\n    this.contextMenuMsg_ = Blockly.Msg.VARIABLES_GET_CREATE_SET;\n    this.contextMenuType_ = 'variables_set';\n  },\n  /**\n   * Return all variables referenced by this block.\n   * @return   List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  },\n  /**\n   * Add menu option to create getter/setter block for this setter/getter.\n   * @param   options List of menu options to add to.\n   * @this Blockly.Block\n   */\n  customContextMenu: function(options) {\n    var option = {enabled: true};\n    var name = this.getFieldValue('VAR');\n    option.text = this.contextMenuMsg_.replace('%1', name);\n    var xmlField = goog.dom.createDom('field', null, name);\n    xmlField.setAttribute('name', 'VAR');\n    var xmlBlock = goog.dom.createDom('block', null, xmlField);\n    xmlBlock.setAttribute('type', this.contextMenuType_);\n    option.callback = Blockly.ContextMenu.callbackFactory(this, xmlBlock);\n    options.push(option);\n  }\n};"
   },
   {
      "functionality":"Blockly.Python['variables_set'] = function(block) {\n  // Variable setter.\n  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',\n      Blockly.Python.ORDER_NONE) || '0';\n  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),\n      Blockly.Variables.NAME_TYPE);\n  return varName + ' = ' + argument0 + '\\n';\n\n};",
      "name":"variables_set",
      "structure":"Blockly.Blocks['variables_set'] = {\n  /**\n   * Block for variable setter.\n   * @this Blockly.Block\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg.VARIABLES_SET_HELPURL);\n    this.setColour(330);\n    this.interpolateMsg(\n        // TODO: Combine these messages instead of using concatenation.\n        Blockly.Msg.VARIABLES_SET_TITLE + ' %1 ' +\n        Blockly.Msg.VARIABLES_SET_TAIL + ' %2',\n        ['VAR', new Blockly.FieldVariable(Blockly.Msg.VARIABLES_SET_ITEM)],\n        ['VALUE', null, Blockly.ALIGN_RIGHT],\n        Blockly.ALIGN_RIGHT);\n    this.setPreviousStatement(true);\n    this.setNextStatement(true);\n    this.setTooltip(Blockly.Msg.VARIABLES_SET_TOOLTIP);\n    this.contextMenuMsg_ = Blockly.Msg.VARIABLES_SET_CREATE_GET;\n    this.contextMenuType_ = 'variables_get';\n  },\n  /**\n   * Return all variables referenced by this block.\n   * @return   List of variable names.\n   * @this Blockly.Block\n   */\n  getVars: function() {\n    return [this.getFieldValue('VAR')];\n  },\n  /**\n   * Notification that a variable is renaming.\n   * If the name matches one of this block's variables, rename it.\n   * @param {string} oldName Previous name of variable.\n   * @param {string} newName Renamed variable.\n   * @this Blockly.Block\n   */\n  renameVar: function(oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {\n      this.setFieldValue(newName, 'VAR');\n    }\n  },\n  customContextMenu: Blockly.Blocks['variables_get'].customContextMenu\n};"
   }
]

function sendBlock(element, index, array) {
    $.ajax({
    url: "http://localhost:3000/blocks/create",
    type: "POST",
    crossDomain: true,
    data: JSON.stringify(element),
    contentType: "application/json",
    success: function (res) {},
    error: function (a, b, c) {console.log(element.name);}
});
}

$(document).ready(function(){
    blocks.forEach(sendBlock);
});
</script>
</html>